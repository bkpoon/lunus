

Sep 19 20:37 1995   Page 1


::::::::::::::
avgim.c
::::::::::::::
/* AVGIM.C - Calculate the average intensity for an input image.

   Author: Mike Wall
   Date: 1/11/95
   Version: 1.

   "avgim <input image>"

   Input is TIFF TV6 image.  Output is a number which is the average
   pixel value in the image.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein;

  char
    error_msg[LINESIZE];

  size_t
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff;

  struct rccoords origin;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;







Sep 19 20:37 1995   Page 2


		default:
			printf("\n Usage: avgim <input image>\n\n");
			exit(0);
	}


/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */
	imdiff->infile = imagein;
	if (lreadim(imdiff) != 0) {
		perror(imdiff->error_msg);
		goto CloseShop;
	}


  /*
   * Calculate average:
   */

	lavgim(imdiff);

/*
 * Write the result:
 */

  printf("%e\n",imdiff->avg_pixel_value);

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);

}

::::::::::::::
avgr.c
::::::::::::::







Sep 19 20:37 1995   Page 3


/* AVGR.C - Generate a table of average voxel values as a function of radius
		for an input 3D lattice.

   Author: Mike Wall
   Date: 3/28/93
   Version: 1.

   Usage:
   		"avgr <input file> <output file>"

   Input is a 3D lattice.  Output is a list of average value by radius, to be
	labelled (0,1,2,3,...).

   */

#include<mwmask.h>

void main(argc, argv)
	short argc;
	char *argv[];
{
  FILE
	*infile,
	*outfile;

  char
    error_msg[LINESIZE];

  size_t
	i,
	j,
	k,
	xyvoxels,
	num_read,
	num_wrote;

  LAT3D
	*lat;

  RFILE_DATA_TYPE *rfile;

  float
	xscale,
	yscale,
	zscale;

/*
 * Set input line defaults:
 */
	
	infile = stdin;
	outfile = stdout;

/*
 * Read information from input line:
 */







Sep 19 20:37 1995   Page 4


	switch(argc) {
		case 3:
			if (strcmp(argv[2],"-") == 0) {
				outfile = stdout;
			}
			else {
			 if ((outfile = fopen(argv[2],"wb")) == NULL) {
				printf("\nCan't open %s.\n\n",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if (strcmp(argv[1],"-") == 0) {
				infile = stdin;
			}
			else {
			 if ( (infile = fopen(argv[1],"rb")) == NULL ) {
				printf("\nCan't open %s.\n\n",argv[1]);
				exit(0);
			 }
			}
		case 1:
			break;
		default:
			printf("\n Usage: avgr <input file> "
				"<output file>\n\n");
			exit(0);
	}

/*
 * Allocate memory for lattice:
 */

  lat = (LAT3D *)malloc(sizeof(LAT3D));
  if (!lat) {
    printf("\n***Unable to allocate all memory.\n");
    goto CloseShop;
  }

/*
 * Set main defaults:
 */

	lat->infile = infile;
	lat->outfile = outfile;
	lat->mask_tag = DEFAULT_LATTICE_MASK_TAG;

/*
 * Read in 3D lattice descriptor:
 */

  num_read = fread(&lat->xvoxels, sizeof(long), 1, infile);
  num_read = fread(&lat->yvoxels, sizeof(long), 1, infile);
  num_read = fread(&lat->zvoxels, sizeof(long), 1, infile);
  num_read = fread(&lat->xbound, sizeof(struct bounds), 1, infile);
  num_read = fread(&lat->ybound, sizeof(struct bounds), 1, infile);







Sep 19 20:37 1995   Page 5


  num_read = fread(&lat->zbound, sizeof(struct bounds), 1, infile);
  xyvoxels = lat->xvoxels * lat->yvoxels;
  lat->lattice_length = xyvoxels * lat->zvoxels;
  lat->rfile_length = 0;

/*
 * Allocate memory for 3D lattice:
 */

  lat->lattice = (LATTICE_DATA_TYPE *)calloc(lat->lattice_length,
				sizeof(LATTICE_DATA_TYPE));
  if (!lat->lattice) {
	printf("\nNot enough room to allocate 3D lattice.\n\n");
	exit(0);
  }

/*
 * Read in lattice:
 */

  num_read = fread(lat->lattice, sizeof(LATTICE_DATA_TYPE), lat->lattice_length,
						infile);
  if (num_read != lat->lattice_length) {
    printf("/nCouldn't read all of the lattice from input file.\n\n");
    exit(0);
  }

/*
 * Allocate memory for rfile:
 */

  lat->rfile = (LATTICE_DATA_TYPE *)calloc(MAX_RFILE_LENGTH,
					sizeof(LATTICE_DATA_TYPE));
  if (!lat->lattice) {
  	printf("\nNot enough room to allocate 3D lattice.\n\n");
  	exit(0);
  }

/*
 * Generate average rfile:
 */

  lavgr(lat);

/*
 * Write rfile to output file:
 */

  num_wrote = fwrite(lat->rfile, sizeof(RFILE_DATA_TYPE), lat->rfile_length,
				outfile);
CloseShop:

  /*
   * Free allocated memory:
   */








Sep 19 20:37 1995   Page 6


  free((LATTICE_DATA_TYPE *)lat->lattice);
  free((LATTICE_DATA_TYPE *)lat->rfile);
  free((LAT3D *)lat);

  /*
   * Close files:
   */

  fclose(infile);
  fclose(outfile);
}

::::::::::::::
avgrf.c
::::::::::::::
/* AVGRF.C - Average the values of an rfile.

   Author: Mike Wall
   Date: 1/12/95
   Version: 1.

   "avgrf <input rfile> <output file>"

   Input is one rfile.  Output is average value to output file.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *infile1,
    *outfile;

  size_t
    i;

  DIFFIMAGE
    *imdiff1;

  /*
   * Set input line defaults:
   */

  infile1 = stdin;
  outfile = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 3:
    if (strcmp(argv[2], "-") == 0) {
      outfile = stdout;
    }







Sep 19 20:37 1995   Page 7


    else {
      if ( (outfile = fopen(argv[2],"w")) == NULL ) {
	printf("Can't open %s.",argv[3]);
	exit(0);
      }
    }
    case 2:
    if ( (infile1 = fopen(argv[1],"rb")) == NULL ) {
      printf("Can't open %s.",argv[1]);
      exit(0);
    }
    break;
    default:
    printf("\n Usage: avgrf <input rfile> "
	   "<output file>\n\n");
    exit(0);
  }

  /*
   * Initialize diffraction images:
   */

  if ((imdiff1 = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

  /*
   * Read in rfile:
   */

  imdiff1->infile = infile1;
  if (lreadrf(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

  /*
   * Average rfile:
   */

  lavgrf(imdiff1);

  /*
   * Write the output rfile:
   */

  fprintf(outfile,"%e\n",imdiff1->rfile[0]);

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff1);







Sep 19 20:37 1995   Page 8



  /*
   * Close files:
   */

  fclose(infile1);
  fclose(outfile);

}
::::::::::::::
avgrim.c
::::::::::::::
/* AVGRIM.C - Calculate the average intensity as a function of radius for an
		input image.

   Author: Mike Wall
   Date: 4/3/93
   Version: 1.

   "avgrim <input image> <output rfile> <x origin> <y origin>"

   Input is TIFF TV6 image.  Output is a list of values of I(r).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*outfile;

  char
    error_msg[LINESIZE];

  size_t
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff;

  struct rccoords origin;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	outfile = stdout;
	origin.r = DEFAULT_IMAGE_ORIGIN;
	origin.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:







Sep 19 20:37 1995   Page 9


 */
	switch(argc) {
		case 5:
			origin.r = (RCCOORDS_DATA)atoi(argv[4]);
		case 4:
			origin.c = (RCCOORDS_DATA)atoi(argv[3]);
		case 3:
			if ( (outfile = fopen(argv[2],"wb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			}
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: avgrim <input image> "
				"<output rfile> <x origin> <y origin>\n\n");
			exit(0);
	}


/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Set defaults:
 */

  imdiff->origin = origin;

/*
 * Read diffraction image:
 */
	imdiff->infile = imagein;
	if (lreadim(imdiff) != 0) {
		perror(imdiff->error_msg);
		goto CloseShop;
	}


  /*
   * Generate rfile:







Sep 19 20:37 1995   Page 10


   */

	lavgrim(imdiff);

/*
 * Write the output rfile:
 */

   imdiff->outfile = outfile;
   if(lwriterf(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(outfile);

}

::::::::::::::
avgrlt.c
::::::::::::::
/* AVGRLT.C - Calculate the average voxel value vs. radius for an
              input lattice

   Author: Mike Wall
   Date: 3/1/95
   Version: 1.

   Usage:
   		"avgrlt <input lattice> <output rfile>"

		Input is a 3D lattice.  Output is an rfile.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *outfile;

  char







Sep 19 20:37 1995   Page 11


    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_wrote;

  LAT3D
    *lat;

  RFILE_DATA_TYPE *rfile;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  latticein = stdin;
  outfile = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 6:
    origin.k = atol(argv[5]);
    case 5:
    origin.j = atol(argv[4]);
    case 4:
    origin.i = atol(argv[3]);
    case 3:
    if ((outfile = fopen(argv[2],"wb")) == NULL) {
      printf("\nCan't open %s.\n\n",argv[2]);
      exit(0);
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein = stdin;
    }
    else {
      if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: avgrlt <input lattice> "
	   "<output lattice> <x-origin> "
	   "<y-origin> <z-origin>\n\n");
    exit(0);
  }








Sep 19 20:37 1995   Page 12


  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the radially averaged image:
 */

  lavgrlt(lat);

/*
 * Write rfile to output file:
 */

  num_wrote = fwrite(lat->rfile, sizeof(RFILE_DATA_TYPE),
		     lat->rfile_length, outfile);
  if (num_wrote != lat->rfile_length) {
    printf("\nCouldn't write rfile.\n\n");
    goto CloseShop;
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(outfile);
  fclose(latticein);
}

::::::::::::::
avgsqim.c
::::::::::::::
/* AVGSQIM.C - Calculate the average square intensity for an input image.







Sep 19 20:37 1995   Page 13



   Author: Mike Wall
   Date: 1/23/95
   Version: 1.

   "avgsqim <input image>"

   Input is TIFF TV6 image.  Output is a number which is the average
   square pixel value in the image.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein;

  char
    error_msg[LINESIZE];

  size_t
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff;

  struct rccoords origin;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: avgsqim <input image>\n\n");
			exit(0);
	}







Sep 19 20:37 1995   Page 14




/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */
	imdiff->infile = imagein;
	if (lreadim(imdiff) != 0) {
		perror(imdiff->error_msg);
		goto CloseShop;
	}


  /*
   * Calculate average:
   */

	lavgsqim(imdiff);

/*
 * Write the result:
 */

  printf("%e\n",imdiff->avg_pixel_value);

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);

}

::::::::::::::
avsqrim.c
::::::::::::::
/* AVSQRIM.C - Calculate the average intensity squared as a function of radius
		for an input image.

   Author: Mike Wall







Sep 19 20:37 1995   Page 15


   Date: 4/18/93
   Version: 1.

   "avsqrim <input image> <output rfile> <x origin> <y origin>"

   Input is TIFF TV6 image.  Output is a list of values of I(r).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*outfile;

  char
    error_msg[LINESIZE];

  size_t
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff;

  struct rccoords origin;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	outfile = stdout;
	origin.r = DEFAULT_IMAGE_ORIGIN;
	origin.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 5:
			origin.r = (RCCOORDS_DATA)atoi(argv[4]);
		case 4:
			origin.c = (RCCOORDS_DATA)atoi(argv[3]);
		case 3:
			if ( (outfile = fopen(argv[2],"wb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			}
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {







Sep 19 20:37 1995   Page 16


			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: avsqrim <input image> "
				"<output rfile> <x origin> <y origin>\n\n");
			exit(0);
	}


/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Set defaults:
 */

  imdiff->origin = origin;

/*
 * Read diffraction image:
 */
	imdiff->infile = imagein;
	if (lreadim(imdiff) != 0) {
		perror(imdiff->error_msg);
		goto CloseShop;
	}


  /*
   * Generate rfile:
   */

	lavsqrim(imdiff);

/*
 * Write the output rfile:
 */

   imdiff->outfile = outfile;
   if(lwriterf(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

CloseShop:








Sep 19 20:37 1995   Page 17


/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(outfile);

}

::::::::::::::
avsqrlt.c
::::::::::::::
/* AVSQRLT.C - Calculate the average square voxel value vs. radius for an
              input lattice

   Author: Mike Wall
   Date: 3/15/95
   Version: 1.

   Usage:
   		"avsqrlt <input lattice> <output rfile>"

		Input is a 3D lattice.  Output is an rfile.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *outfile;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_wrote;

  LAT3D
    *lat;

  RFILE_DATA_TYPE *rfile;

  struct ijkcoords
    origin;








Sep 19 20:37 1995   Page 18


  /*
   * Set input line defaults:
   */

  latticein = stdin;
  outfile = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 6:
    origin.k = atol(argv[5]);
    case 5:
    origin.j = atol(argv[4]);
    case 4:
    origin.i = atol(argv[3]);
    case 3:
    if ((outfile = fopen(argv[2],"wb")) == NULL) {
      printf("\nCan't open %s.\n\n",argv[2]);
      exit(0);
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein = stdin;
    }
    else {
      if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: avsqrlt <input lattice> "
	   "<output rfile> <x-origin> "
	   "<y-origin> <z-origin>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");







Sep 19 20:37 1995   Page 19


    exit(0);
  }

/*
 * Generate the radially averaged square voxel value rfile:
 */

  lavsqrlt(lat);

/*
 * Write rfile to output file:
 */

  num_wrote = fwrite(lat->rfile, sizeof(RFILE_DATA_TYPE),
		     lat->rfile_length, outfile);
  if (num_wrote != lat->rfile_length) {
    printf("\nCouldn't write rfile.\n\n");
    goto CloseShop;
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(outfile);
  fclose(latticein);
}

::::::::::::::
binasc.c
::::::::::::::
/* BINASC.C - Convert a list of floating points binary inputs to ascii and
		reverse.
   Author: Mike Wall
   Date: 3/29/94
   Version: 1.0
   Description:

		"binasc [options] < input > output"

		Input is a binary/ascii stream.
		Output is a list of ascii/binary numbers.
*/

#include<mwmask.h>
#define SCALE 200.

void main(int argc, char *argv[])







Sep 19 20:37 1995   Page 20


{
  float
    x,
    y,
    z,
    upper,
    lower,
    scale_factor,
    value;
  size_t
    i;

  int
    option = 0;

  char
    input_string[LINESIZE];

  short
    shortvalue;

  /*
   * Read information from input line:
   */

  switch(argc) {
    case 4:
    upper = atof(argv[3]);
    case 3:
    scale_factor = atof(argv[2]);
    case 2:
    option = atoi(argv[1]);
    break;
    default:
    printf("\nUsage:  binasc [options] [scale_factor] < [input file] > "
	   "[output file]\n\n"
	   "    Options:\n"
	   "       0: float input -> ascii output\n"
	   "       1: ascii input -> float output\n"
	   "       2: float input -> ascii output w/ leading index\n"
	   "       3: ascii input w/ leading index -> float output\n"
	   "       4: ascii input * scale_factor -> float output\n"
	   "       5: float input -> scaled image\n"
	   "       6: float input -> short output\n"
	   "       7: short input -> float output\n"
	   "       8: (x,y,z,I) ascii input -> (x,y,z,I) float output\n\n");
    exit(0);
  }

  switch(option) {
    case 0:
    while (fread (&value, sizeof(float), 1, stdin) == 1) {
      printf("%f\n",value);
    }
    break;
    case 1:







Sep 19 20:37 1995   Page 21


    while (fgets (input_string, LINESIZE, stdin) != NULL) {
      sscanf(input_string, "%g", &value);
      fwrite(&value, sizeof(float), 1, stdout);
    }
    break;
    case 2:
    i=0;
    while (fread (&value, sizeof(float), 1, stdin) == 1) {
      printf("%ld %f\n",i,value);
      i++;
    }
    break;
    case 3:
    while (fgets (input_string, LINESIZE, stdin) != NULL) {
      sscanf(input_string, "%ld %g", &i, &value);
      fwrite(&value, sizeof(float), 1, stdout);
    }
    break;
    case 4:
    while (fgets (input_string, LINESIZE, stdin) != NULL) {
      sscanf(input_string, "%g", &value);
      value *= scale_factor;
      fwrite(&value, sizeof(float), 1, stdout);
    }
    break;
    case 5:
    lower = scale_factor;
    scale_factor = upper - lower;
    while (fread (&value, sizeof(float), 1, stdin) == 1) {
      if (value <= lower) {
	value = 0;
      }
      if (value >= upper) {
	value = 255.;
      }
      if ((value > lower) && (value < upper)) {
	value = (value - lower) / (scale_factor) * 255.;
      }
      fwrite(&value, sizeof(float), 1, stdout);
    }
    break;
    case 6:
    while (fread (&value, sizeof(float),1,stdin) == 1) {
      shortvalue = (short)value;
      fwrite(&shortvalue, sizeof(short), 1, stdout);
    }
    break;
    case 7:
    while (fread (&shortvalue, sizeof(short),1,stdin) == 1) {
      value = (float)shortvalue;
      fwrite(&value, sizeof(float), 1, stdout);
    }
    break;
    case 8:
    while (fgets (input_string, LINESIZE, stdin) != NULL) {
      sscanf(input_string, "%g %g %g %g", &x, &y, &z, &value);







Sep 19 20:37 1995   Page 22


      fwrite(&x, sizeof(float), 1, stdout);
      fwrite(&y, sizeof(float), 1, stdout);
      fwrite(&z, sizeof(float), 1, stdout);
      fwrite(&value, sizeof(float), 1, stdout);
    }
    break;
    default:
    printf("\nUsage:  binasc [options] < [input file] > [output file]\n\n"
	   "    Options:\n"
	   "       0: float input -> ascii output\n"
	   "       1: ascii input -> float output\n"
	   "       2: float input -> ascii output w/ leading index\n"
	   "       3: ascii input w/ leading index -> float output\n"
	   "       4: ascii input * scale_factor -> float output\n"
	   "       5: float input -> scaled image\n"
	   "       6: float input -> short output\n"
	   "       7: short input -> float output\n"
	   "       8: (x,y,z,I) ascii input -> (x,y,z,I) float output\n\n");
    exit(0);
  }
}





::::::::::::::
buttim.c
::::::::::::::
/* BUTTIM.C - Mask a diffraction image using a butterfly shape.

   Author: Mike Wall
   Date: 6/22/94
   Version: 1.

   "buttim <image in> <image out> <x origin> <y origin>
      <offset angle> <opening angle>"

   Input is diffraction image.  Output is masked image.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff;








Sep 19 20:37 1995   Page 23


  struct rccoords
	origin;

  float
    butterfly_offset,
    opening_angle;


/*
 * Set input line defaults:
 */
  origin.r = DEFAULT_IMAGE_ORIGIN;
  origin.c = DEFAULT_IMAGE_ORIGIN;

  butterfly_offset = DEFAULT_BUTTERFLY_OFFSET;
  opening_angle = DEFAULT_OPENING_ANGLE;
  imagein = stdin;
  imageout = stdout;

/*
 * Read information from input line:
 */
 switch(argc) {
 case 7:
 opening_angle = atof(argv[6]);
 case 6:
 butterfly_offset = atof(argv[5]);
	  case 5:
	  origin.r = (RCCOORDS_DATA)atol(argv[4]);
	  case 4:
	  origin.c = (RCCOORDS_DATA)atol(argv[3]);
	  case 3:
	  if (strcmp(argv[2], "-") == 0) {
	    imageout = stdout;
	  }
	  else {
	    if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	      printf("Can't open %s.",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1], "-") == 0) {
	    imagein = stdin;
	  }
	  else {
	    if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	      printf("Can't open %s.",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: polarim <image in> <image out> "
		 "<x origin> <y origin> <butterfly_offset> "
		 "<opening angle>\n\n");







Sep 19 20:37 1995   Page 24


	  exit(0);
	}

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

  /*
   * Set the origin for the image:
   */

  imdiff->origin = origin;

  /*
   * Set the butterfly parameters:
   */

  imdiff->polarization = opening_angle;
  imdiff->polarization_offset = butterfly_offset;

  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Mask image:
   */

  lbuttim(imdiff);

  /*
   * Write the output image:
   */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  CloseShop:

  /*
   * Free allocated memory:
   */







Sep 19 20:37 1995   Page 25



  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(imageout);

}


::::::::::::::
constim.c
::::::::::::::
/* CONSTIM - Create an image with constant pixel value based on an input
		image format.

   Author: Mike Wall
   Date: 4/18/94
   Version: 1.

   "constim <image in> <constant> <image out>"

   Input is image and constant.  Output is constant image of type input image.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff;

  IMAGE_DATA_TYPE
	image_value;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */







Sep 19 20:37 1995   Page 26


	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
                case 3:
			image_value = atof(argv[2]);
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: constim <image in> <constant> "
			       "<image out>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }


 /*
  * Read diffraction image:
  */

   imdiff->infile = imagein;
   if (lreadim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

/*
 * Set image to constant:
 */

   imdiff->image[0] = (IMAGE_DATA_TYPE)image_value;
   lconstim(imdiff);







Sep 19 20:37 1995   Page 27



/*
 * Write the output image:
 */

   imdiff->outfile = imageout;
   if(lwriteim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
constlt.c
::::::::::::::
/* CONSTLT.C - Create a constant lattice, using an input lattice as a */
/* template.

   Author: Mike Wall
   Date: 8/5/95
   Version: 1.

   Usage:
   		"constlt <input lattice> <output lattice> <constant>"

		Input is a scalar and an input
			lattice.  Output is a lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *latticeout;

  char
    error_msg[LINESIZE];








Sep 19 20:37 1995   Page 28


  size_t
    i,
    j,
    k,
    num_read,
    num_wrote;

  LAT3D
    *lat;

  RFILE_DATA_TYPE
    *rfile;

  float
    scale_factor;

/*
 * Set input line defaults:
 */
	scale_factor = 1.;
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 4:
	  scale_factor = atof(argv[3]);
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    latticeout = stdout;
	  }
	  else {
	    if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: constlt <input lattice> <output lattice> "
		 "<constant>\n\n");
	  exit(0);
	}








Sep 19 20:37 1995   Page 29


  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the constant lattice:
 */

  lat->rfile[0] = scale_factor;
  lconstlt(lat);

/*
 * Write lattice to output file:
 */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(latticeout);
}

::::::::::::::
constrf.c
::::::::::::::
/* CONSTRF.C - Create an rfile with the value of a constant give at the







Sep 19 20:37 1995   Page 30


		input line.

   Author: Mike Wall
   Date: 4/19/94
   Version: 1.

   "constrf <input rfile> <constant> <output rfile>"

   Input is an rfile and a constant.  Output is an rfile with all values
   equal to constant, in the format of the input rfile.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile,
	*outfile;

  size_t
    i;

  DIFFIMAGE
	*imdiff;

  RFILE_DATA_TYPE
	rfile_value;

/*
 * Set input line defaults:
 */
	
	infile = stdin;
	outfile = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				outfile = stdout;
			}
			else {
			 if ( (outfile = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			rfile_value = (RFILE_DATA_TYPE)atof(argv[2]);
		case 2:
			if ( (infile = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);







Sep 19 20:37 1995   Page 31


				exit(0);
			}
			break;
		default:
			printf("\n Usage: constrf <input rfile> "
				"<constant> <output rfile>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction images:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

 /*
  * Read in rfiles:
  */

   imdiff->infile = infile;
   if (lreadrf(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

/*
 * Create constant rfile:
 */

   imdiff->rfile[0] = rfile_value;
   lconstrf(imdiff);

/*
 * Write the output rfile:
 */

   imdiff->outfile = outfile;
   if(lwriterf(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */







Sep 19 20:37 1995   Page 32



  fclose(infile);
  fclose(outfile);

}

::::::::::::::
culllt.c
::::::::::::::
/* CULLLT.C - Multiply each voxel in a lattice by a scalar.

   Author: Mike Wall
   Date: 4/26/95
   Version: 1.

   Usage:
   		"culllt <input lattice> <output lattice> <inner
		radius> <outer radius>"

		Input is a scalar and a range
		Output is a culled lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_read,
    num_wrote;

  LAT3D
    *lat;

  RFILE_DATA_TYPE
    *rfile;

  float
    inner_radius,
    outer_radius;

/*
 * Set input line defaults:
 */
  latticein = stdin;
  latticeout = stdout;







Sep 19 20:37 1995   Page 33


  inner_radius = DEFAULT_INNER_RADIUS;
  outer_radius = DEFAULT_OUTER_RADIUS;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 5:
	  outer_radius = atof(argv[4]);
	  case 4:
	  inner_radius = atof(argv[3]);
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    latticeout = stdout;
	  }
	  else {
	    if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: culllt <input lattice> "
		 "<output lattice> <inner radius> <outer radius>"
		 "\n\n");
	  exit(0);
	}

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);







Sep 19 20:37 1995   Page 34


  }

/*
 * Cull the lattice:
 */

  lat->inner_radius = inner_radius;
  lat->outer_radius = outer_radius;
  lculllt(lat);

/*
 * Write lattice to output file:
 */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(latticeout);
}


::::::::::::::
cutim.c
::::::::::::::
/* CUTIM.C - "Cut" a rectangle out of an image by marking pixels
     with ignore tags.

   Author: Mike Wall
   Date: 1/13/95
   Version: 1.

   "cutim <image in> <x_lower_bound> <x_upper_bound> <y_lower_bound>
		<y_upper_bound> <image out>

   Input is diffraction image.  Output is 16-bit
     image of specified size (1024 x 1024 default), with pixels inside bounds
     marked to be ignored.

   */








Sep 19 20:37 1995   Page 35


#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  char
    error_msg[LINESIZE];

  long
	i,
	ii;

  DIFFIMAGE
	*imdiff;

  struct rccoords
	upper_bound,
	lower_bound;

/*
 * Set input line defaults:
 */
	upper_bound.r = DEFAULT_WINDOW_UPPER;
	upper_bound.c = DEFAULT_WINDOW_UPPER;
	lower_bound.c = DEFAULT_WINDOW_LOWER;
	lower_bound.c = DEFAULT_WINDOW_LOWER;
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 7:
			if (strcmp(argv[6], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[6],"wb")) == NULL ) {
				printf("Can't open %s.",argv[6]);
				exit(0);
			 }
			}
		case 6:
			upper_bound.r = (RCCOORDS_DATA)atol(argv[5]);
		case 5:
			lower_bound.r = (RCCOORDS_DATA)atol(argv[4]);
		case 4:
			upper_bound.c = (RCCOORDS_DATA)atol(argv[3]);
		case 3:
			lower_bound.c = (RCCOORDS_DATA)atol(argv[2]);
		case 2:
			if (strcmp(argv[1], "-") == 0) {







Sep 19 20:37 1995   Page 36


				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: cutim <image in> <x_lower_bound> "
			       "<x_upper_bound> <y_lower_bound> "
			       "<y_upper_bound> <image out> \n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

/*
 * Set window parameters:
 */

  imdiff->window_upper = upper_bound;
  imdiff->window_lower = lower_bound;

/*
 * Mark pixels inside window as ignored:
 */

  lcutim(imdiff);

/*
 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;







Sep 19 20:37 1995   Page 37


  }

CloseShop:

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}


::::::::::::::
df2im.c
::::::::::::::
/* DF2IM.C - Generate an image based upon a diffuse features file.

   Author: Mike Wall
   Date: 5/30/94
   Version: 1.0

   "df2im <diffuse features in> <template image in> <image out>"

   Input is ascii diffuse features file and input template image.  Output is
   diffuse features file.

*/

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *featurein,
    *imageout,
    *imagein;

  char
    error_msg[LINESIZE];

  DIFFIMAGE
    *imdiff;

  /*
   * Set input line defaults:
   */

  featurein = stdin;
  imagein = stdin;
  imageout = stdout;

  /*







Sep 19 20:37 1995   Page 38


   * Read information from input line:
   */

  switch(argc) {
  case 4:
    if (strcmp(argv[3], "-") == 0) {
      imageout = stdout;
    }
    else {
      if ( (imageout = fopen(argv[3],"wb")) == NULL ) {
	printf("Can't open %s.",argv[3]);
	exit(0);
      }
    }
  case 3:
    if (strcmp(argv[2], "-") == 0) {
      imagein = stdin;
    }
    else {
      if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }
    }
  case 2:
    if ( (featurein = fopen(argv[1],"r")) == NULL ) {
      printf("Can't open %s.",argv[1]);
      exit(0);
    }
    break;
  default:
    printf("\n Usage: df2im <diffuse features in> "
	   "<template image in> <image out> \n\n");
    exit(0);
  }

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*







Sep 19 20:37 1995   Page 39


   * Read diffuse features file:
   */

  imdiff->infile = featurein;
  if (lreaddf(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Generate an image from diffuse features:
   */

  if (ldf2im(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Write the output diffuse features file:
   */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  CloseShop:

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(featurein);
  fclose(imageout);
}












::::::::::::::
dfrflt.c
::::::::::::::
/* DFRFLT.C - Calculate an R-factor rfile for two input lattices.







Sep 19 20:37 1995   Page 40



   Author: Mike Wall
   Date: 7/9/95
   Version: 1.

   Usage:
   		"dfrflt <input lattice 1> <input lattice 2> <output
		rfile>"

		Input is two 3D lattices.  Output is an rfile.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2,
    *outfile;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_wrote;

  LAT3D
    *lat1,
    *lat2;

  RFILE_DATA_TYPE *rfile;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  latticein1 = stdin;
  latticein2 = stdin;
  outfile = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 4:
    if ((outfile = fopen(argv[3],"wb")) == NULL) {
      printf("\nCan't open %s.\n\n",argv[3]);
      exit(0);
    }







Sep 19 20:37 1995   Page 41


    case 3:
    if (strcmp(argv[2],"-") == 0) {
      latticein2 = stdin;
    }
    else {
      if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein1 = stdin;
    }
    else {
      if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: dfrflt <input lattice 1> <input lattice 2>"
	   "<output rfile>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if (((lat1 = linitlt()) == NULL) || ((lat2 = linitlt()) == NULL)) {
    perror("Couldn't initialize lattices.\n\n");
    exit(0);
  }

  /*
   * Read in lattices:
   */

  lat1->infile = latticein1;
  if (lreadlt(lat1) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  lat2->infile = latticein2;
  if (lreadlt(lat2) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the normalized difference squared:
 */








Sep 19 20:37 1995   Page 42


  ldfrflt(lat1,lat2);

/*
 * Write rfile to output file:
 */

  num_wrote = fwrite(lat1->rfile, sizeof(RFILE_DATA_TYPE),
		     lat1->rfile_length, outfile);
  if (num_wrote != lat1->rfile_length) {
    printf("\nCouldn't write rfile.\n\n");
    goto CloseShop;
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat1);
  lfreelt(lat2);

  /*
   * Close files:
   */

  fclose(outfile);
  fclose(latticein1);
  fclose(latticein2);
}

::::::::::::::
dfsqrlt.c
::::::::::::::
/* DFSQRLT.C - Calculate the normalized difference squared voxel value */
/* vs.  radius between two input lattices in radial shells

   Author: Mike Wall
   Date: 3/15/95
   Version: 1.

   Usage:
   		"dfsqrlt <input lattice 1> <input lattice 2> <output
		rfile>"

		Input is two 3D lattices.  Output is an rfile.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2,
    *outfile;







Sep 19 20:37 1995   Page 43



  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_wrote;

  LAT3D
    *lat1,
    *lat2;

  RFILE_DATA_TYPE *rfile;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  latticein1 = stdin;
  latticein2 = stdin;
  outfile = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 4:
    if ((outfile = fopen(argv[3],"wb")) == NULL) {
      printf("\nCan't open %s.\n\n",argv[3]);
      exit(0);
    }
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      latticein2 = stdin;
    }
    else {
      if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein1 = stdin;
    }
    else {
      if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }







Sep 19 20:37 1995   Page 44


    break;
    default:
    printf("\n Usage: dfsqrlt <input lattice 1> <input lattice 2>"
	   "<output rfile>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if (((lat1 = linitlt()) == NULL) || ((lat2 = linitlt()) == NULL)) {
    perror("Couldn't initialize lattices.\n\n");
    exit(0);
  }

  /*
   * Read in lattices:
   */

  lat1->infile = latticein1;
  if (lreadlt(lat1) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  lat2->infile = latticein2;
  if (lreadlt(lat2) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the normalized difference squared:
 */

  ldfsqrlt(lat1,lat2);

/*
 * Write rfile to output file:
 */

  num_wrote = fwrite(lat1->rfile, sizeof(RFILE_DATA_TYPE),
		     lat1->rfile_length, outfile);
  if (num_wrote != lat1->rfile_length) {
    printf("\nCouldn't write rfile.\n\n");
    goto CloseShop;
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat1);







Sep 19 20:37 1995   Page 45


  lfreelt(lat2);

  /*
   * Close files:
   */

  fclose(outfile);
  fclose(latticein1);
  fclose(latticein2);
}

::::::::::::::
divlt.c
::::::::::::::
/* DIVLT.C - Calculate the voxel-by-voxel quotient of two lattices.

   Author: Mike Wall
   Date: 4/11/95
   Version: 1.

   Usage:
   		"divlt <input lattice 1> <input lattice 2> <output
		lattice>"

		Input is two 3D lattices.  Output is a lattice which
		is the quotient of the two.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_wrote;

  LAT3D
    *lat1,
    *lat2;

  RFILE_DATA_TYPE *rfile;

  struct ijkcoords
    origin;

  /*







Sep 19 20:37 1995   Page 46


   * Set input line defaults:
   */

  latticein1 = stdin;
  latticein2 = stdin;
  latticeout = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 4:
    if ((latticeout = fopen(argv[3],"wb")) == NULL) {
      printf("\nCan't open %s.\n\n",argv[3]);
      exit(0);
    }
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      latticein2 = stdin;
    }
    else {
      if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein1 = stdin;
    }
    else {
      if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: mullt <input lattice 1> <input lattice 2> "
	   "<output lattice>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if (((lat1 = linitlt()) == NULL) || ((lat2 = linitlt()) == NULL)) {
    perror("Couldn't initialize lattices.\n\n");
    exit(0);
  }

  /*
   * Read in lattices:
   */








Sep 19 20:37 1995   Page 47


  lat1->infile = latticein1;
  if (lreadlt(lat1) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  lat2->infile = latticein2;
  if (lreadlt(lat2) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the product lattice:
 */

  ldivlt(lat1,lat2);

  /*
   * Write lattice to output file:
   */

  lat1->outfile = latticeout;
  if (lwritelt(lat1) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat1);
  lfreelt(lat2);

  /*
   * Close files:
   */

  fclose(latticeout);
  fclose(latticein1);
  fclose(latticein2);
}

::::::::::::::
divrf.c
::::::::::::::
/* DIVRF.C - Divide two one rfile by another.

   Author: Mike Wall
   Date: 4/19/94
   Version: 1.

   "divrf <input rfile 1> <input rfile 2> <output rfile>"







Sep 19 20:37 1995   Page 48



   Input is two rfiles.  Output is first rfile divided point-by-point by the
   second.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile1,
	*infile2,
	*outfile;

  size_t
    i;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

/*
 * Set input line defaults:
 */
	
	infile1 = stdin;
	infile2 = stdin;
	outfile = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				outfile = stdout;
			}
			else {
			 if ( (outfile = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				infile2 = stdin;
			}
			else {
			 if ( (infile2 = fopen(argv[2],"rb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ( (infile1 = fopen(argv[1],"rb")) == NULL ) {







Sep 19 20:37 1995   Page 49


				printf("Can't open %s.",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: divrf <input rfile 1> "
				"<input rfile 2> <output rfile>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction images:
 */

  if ((imdiff1 = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

  if ((imdiff2 = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

 /*
  * Read in rfiles:
  */

   imdiff1->infile = infile1;
   if (lreadrf(imdiff1) != 0) {
     perror(imdiff1->error_msg);
     goto CloseShop;
   }

   imdiff2->infile = infile2;
   if (lreadrf(imdiff2) != 0) {
     perror(imdiff2->error_msg);
     goto CloseShop;
   }

/*
 * Divide rfiles:
 */

   ldivrf(imdiff1,imdiff2);

/*
 * Write the output rfile:
 */

   imdiff1->outfile = outfile;
   if(lwriterf(imdiff1) != 0) {
     perror(imdiff1->error_msg);
     goto CloseShop;
   }








Sep 19 20:37 1995   Page 50


 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(infile1);
  fclose(infile2);
  fclose(outfile);

}

::::::::::::::
dos2unix.c
::::::::::::::
#include<stdio.h>
#include<stdlib.h>

#define CR 13
#define END_OF_STREAM 255

void main(void)
{
	char
		ch;

	while ((ch = getchar()) != END_OF_STREAM) {
		if (ch != CR) putchar(ch);
	}
}


::::::::::::::
explt.c
::::::::::::::
/* EXPLT.C - Multiply each voxel in a lattice by an exponential.

   Author: Mike Wall
   Date: 3/21/95
   Version: 1.

   Usage:
   		"explt <input lattice> <width> <output lattice>"

		Input is a scalar and an input
			lattice.  Output is a lattice.
   */

#include<mwmask.h>







Sep 19 20:37 1995   Page 51



void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_read,
    num_wrote;

  LAT3D
    *lat;

  RFILE_DATA_TYPE
    *rfile;

  float
    scale_factor;

/*
 * Set input line defaults:
 */
	scale_factor = 1.;
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 4:
	  scale_factor = atof(argv[3]);
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    latticeout = stdout;
	  }
	  else {
	    if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);







Sep 19 20:37 1995   Page 52


	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: mulsclt <input lattice> <output lattice> "
		 "<scale factor>\n\n");
	  exit(0);
	}

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the scaled lattice:
 */

  lat->rfile[0] = scale_factor;
  lexplt(lat);

/*
 * Write lattice to output file:
 */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:







Sep 19 20:37 1995   Page 53


   */

  fclose(latticein);
  fclose(latticeout);
}


::::::::::::::
fftim.c
::::::::::::::
/* FFTIM.C - Calculate the fft of an image.

   Author: Mike Wall
   Date: 3/15/95
   Version: 1.

   Usage:
   		"fftim <real input image> <imaginary input image>
		<real FFT image> <imaginary FFT image> <isign>"

		Input is real and imaginary image.  Output is FFT of image.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *imagein1,
    *imagein2,
    *imageout1,
    *imageout2;

  char
    error_msg[LINESIZE];

  DIFFIMAGE
    *imdiff;

  IMAGE_DATA_TYPE
    *image1,
    *image2;

  float
    inverse_scale = 1048576.,
    *fft_data;

  size_t
    fft_index,
    image_index,
    i,
    j,
    k;

  int
    imaginput = 0,







Sep 19 20:37 1995   Page 54


    nn[3],
    ndim = 2,
    isign = 1;
/*
 * Set input line defaults:
 */
	
  imagein1 = stdin;
  imagein2 = stdin;
  imageout1 = stdout;
  imageout2 = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 6:
	  isign = atoi(argv[5]);
	  case 5:
	  if (strcmp(argv[4],"-") == 0) {
	    imageout2 = stdout;
	  }
	  else {
	    if ((imageout2 = fopen(argv[4],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[4]);
	      exit(0);
	    }
	  }
	  case 4:
	  if (strcmp(argv[3],"-") == 0) {
	    imageout1 = stdout;
	  }
	  else {
	    if ((imageout1 = fopen(argv[3],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[3]);
	      exit(0);
	    }
	  }
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    imaginput = 0;
	  }
	  else {
	    if ( (imagein2 = fopen(argv[2],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[2]);
	      exit(0);
	    }
	    imaginput = 1;
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    imagein1 = stdin;
	  }
	  else {
	    if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);







Sep 19 20:37 1995   Page 55


	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: fftim <input real image> <input imag image>"
		 "<output real image> <output imag image>\n\n");
	  exit(0);
	}

  /*
   * Initialize images:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize image.\n\n");
    exit(0);
  }

  /*
   * Read in real image:
   */

  imdiff->infile = imagein1;
  if (lreadim(imdiff) != 0) {
    perror("Couldn't read image.\n\n");
    exit(0);
  }
  image1 = imdiff->image;

  /*
   * Read in imaginary image if on input line;  Otherwise, set it
   * to zero:
   */

  image2 = (IMAGE_DATA_TYPE *)calloc(imdiff->image_length,
				     sizeof(IMAGE_DATA_TYPE));
  if(imaginput) {
    imdiff->image = image2;
    imdiff->infile = imagein2;
    if (lreadim(imdiff) != 0) {
      perror("Couldn't read image.\n\n");
      exit(0);
    }
  }

  /*
   * Allocate memory for fft data array:
   */

  fft_data = (float *)calloc((imdiff->image_length+1)*2,sizeof(float));
  if (!fft_data) {
    perror("Couldn't allocate fft data array.\n\n");
    exit(0);
  }








Sep 19 20:37 1995   Page 56


  /*
   * Prepare image for fft:
   */

  printf("Preparing lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  for(i=0;i<imdiff->vpixels;i++) {
    for(j=0;j<imdiff->hpixels;j++) {
      image_index =
	imdiff->hpixels*((j+imdiff->vpixels/2)%imdiff->vpixels) +
	  (i+imdiff->hpixels/2)%imdiff->hpixels;
      fft_data[fft_index] = (float)image1[image_index];
      fft_data[fft_index+1] = (float)image2[image_index];
      fft_index = fft_index + 2;
    }
    /*printf("%d,%d,%d: %f\n",i,j,k,fft_data[fft_index-2]);/***/
  }
printf("...done.\n");/***/
  /*
   * Calculate FFT :
   */

  nn[1] = 1024;
  nn[2] = 1024;
printf("Entering FFT...\n");
  lfft(fft_data,nn,ndim,isign);
printf("...done.\n");
  /*
   * Extract lattice from fft data array -- take magnitude.
   */

printf("Extracting lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  for(i=0;i<imdiff->vpixels;i++) {
    for(j=0;j<imdiff->hpixels;j++) {
      image_index =
	imdiff->hpixels*((j+imdiff->vpixels/2)%imdiff->vpixels) +
	  (i+imdiff->hpixels/2)%imdiff->hpixels;
      image1[image_index] = (IMAGE_DATA_TYPE)(1./inverse_scale*
					      fft_data[fft_index]);
      image2[image_index] = (IMAGE_DATA_TYPE)(1./inverse_scale*
					      fft_data[fft_index+1]);
      fft_index = fft_index+2;
    }
  }
printf("...done. fft_index = %d,%d\n",fft_index,image_index);

  /*
   * Write images to output file:
   */
printf("Writing images...\n");/***/
  imdiff->image = image1;
  imdiff->outfile = imageout1;
  if (lwriteim(imdiff) != 0) {
    perror("Couldn't write image.\n\n");
    exit(0);







Sep 19 20:37 1995   Page 57


  }

printf("Writing image...\n");/***/
  imdiff->image = image2;
  imdiff->outfile = imageout2;
  if (lwriteim(imdiff) != 0) {
    perror("Couldn't write image.\n\n");
    exit(0);
  }


CloseShop:

  /*
   * Free allocated memory:
   */
printf("Freeing memory...\n");
  lfreeim(imdiff);
  free((IMAGE_DATA_TYPE *)image1);
  free((float *)fft_data);

  /*
   * Close files:
   */
printf("Closing files...\n");
  fclose(imagein1);
  fclose(imagein2);
  fclose(imageout1);
  fclose(imageout2);
}


::::::::::::::
fftlt.61.c
::::::::::::::
/* FFTLT.C - Calculate the fft of a lattice.

   Author: Mike Wall
   Date: 2/28/95
   Version: 1.

   Usage:
   		"fftlt <real input lattice> <imaginary input lattice>
		<real FFT lattice> <imaginary FFT lattice>"

		Input is real and imaginary lattice.  Output is FFT of lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2,
    *latticeout1,







Sep 19 20:37 1995   Page 58


    *latticeout2;

  char
    error_msg[LINESIZE];

  LAT3D
    *lat;

  LATTICE_DATA_TYPE
    *lattice1,
    *lattice2;

  float
    *fft_data;

  size_t
    fft_index,
    lat_index,
    i,
    j,
    k;

  int
    imaginput = 0,
    nn[4],
    ndim = 3,
    isign = 1;
/*
 * Set input line defaults:
 */
	
  latticein1 = stdin;
  latticein2 = stdin;
  latticeout1 = stdout;
  latticeout2 = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 5:
	  if (strcmp(argv[4],"-") == 0) {
	    latticeout2 = stdout;
	  }
	  else {
	    if ((latticeout2 = fopen(argv[4],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[4]);
	      exit(0);
	    }
	  }
	  case 4:
	  if (strcmp(argv[3],"-") == 0) {
	    latticeout1 = stdout;
	  }
	  else {
	    if ((latticeout1 = fopen(argv[3],"wb")) == NULL) {







Sep 19 20:37 1995   Page 59


	      printf("\nCan't open %s.\n\n",argv[3]);
	      exit(0);
	    }
	  }
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    imaginput = 0;
	  }
	  else {
	    if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[2]);
	      exit(0);
	    }
	    imaginput = 1;
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein1 = stdin;
	  }
	  else {
	    if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: fftlt <input real lattice> <input imag lattice>"
		 "<output real lattice> <output imag lattice>\n\n");
	  exit(0);
	}

  /*
   * Initialize lattices:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in real lattice:
   */

  lat->infile = latticein1;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }
  lattice1 = lat->lattice;

  /*
   * Read in imageinary lattice if on input line;  Otherwise, set it
   * to zero:
   */







Sep 19 20:37 1995   Page 60



  if(imaginput) {
    lat->lattice = NULL;
    lat->infile = latticein2;
    if (lreadlt(lat) != 0) {
      perror("Couldn't read lattice.\n\n");
      exit(0);
    }
    lattice2 = lat->lattice;
  } else {
    lattice2 = (LATTICE_DATA_TYPE *)calloc(lat->lattice_length,
					   sizeof(LATTICE_DATA_TYPE));
  }

  /*
   * Allocate memory for fft data array:
   */

  fft_data = (float *)calloc(64*64*64*2+1,sizeof(float));
  if (!fft_data) {
    perror("Couldn't allocate fft data array.\n\n");
    exit(0);
  }

  /*
   * Prepare lattice for fft:
   */

printf("Preparing lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  lat_index = 0;
  for(i=0;i<64;i++) {
    for(j=0;j<64;j++) {
      for(k=0;k<64;k++) {
	if ((i > 1) && (i < 63) && (j > 1) && (j < 63) &&
	    (k > 1) && (k < 63)) {
	  fft_data[fft_index] = (float)lattice1[lat_index];
	  fft_data[fft_index+1] = (float)lattice2[lat_index];
	  lat_index++;
	  fft_index = fft_index + 2;
	} else {
	  fft_index = fft_index + 2;
	}
/*printf("%d,%d,%d: %f\n",i,j,k,fft_data[fft_index-2]);/***/
      }
    }
  }
printf("...done.\n");/***/
  /*
   * Calculate FFT :
   */

  nn[1] = 64;
  nn[2] = 64;
  nn[3] = 64;
printf("Entering FFT...\n");







Sep 19 20:37 1995   Page 61


  lfft(fft_data,nn,ndim,isign);
printf("...done.\n");
  /*
   * Extract lattice from fft data array -- take magnitude.
   */

printf("Extracting lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  lat_index = 0;
  for(i=0;i<64;i++) {
    for(j=0;j<64;j++) {
      for(k=0;k<64;k++) {
	if ((i > 1) && (i < 63) && (j > 1) && (j < 63) &&
	    (k > 1) && (k < 63)) {
	  fft_index = 1 + (4096*((i+32)%64) + 64*((j+32)%64) + (k+32)%64)*2;
	  lattice1[lat_index] = (LATTICE_DATA_TYPE)fft_data[fft_index];
	  lattice2[lat_index] = (LATTICE_DATA_TYPE)fft_data[fft_index+1];
	  lat_index++;
	}
      }
    }
  }
printf("...done. fft_index = %d,%d\n",fft_index,lat_index);

  /*
   * Prepare lattice for output:
   */

  lat->xscale = 1./lat->xscale*1/64.;
  lat->yscale = 1./lat->yscale*1/64.;
  lat->zscale = 1./lat->zscale*1/64.;
  lat->xbound.min = - (LATTICE_DATA_TYPE)(lat->origin.i*lat->xscale);
  lat->xbound.max = (LATTICE_DATA_TYPE)((lat->xvoxels -
					lat->origin.i - 1)*lat->xscale);
  lat->ybound.min = - (LATTICE_DATA_TYPE)(lat->origin.j*lat->yscale);
  lat->ybound.max = (LATTICE_DATA_TYPE)((lat->yvoxels -
					lat->origin.j - 1)*lat->yscale);
  lat->zbound.min = - (LATTICE_DATA_TYPE)(lat->origin.i*lat->zscale);
  lat->zbound.max = (LATTICE_DATA_TYPE)((lat->zvoxels -
					lat->origin.k - 1)*lat->zscale);

  /*
   * Write lattices to output file:
   */
printf("Writing lattice...\n");/***/
  lat->lattice = lattice1;
  lat->outfile = latticeout1;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

printf("Writing lattice...\n");/***/
  lat->lattice = lattice2;
  lat->outfile = latticeout2;
  if (lwritelt(lat) != 0) {







Sep 19 20:37 1995   Page 62


    perror("Couldn't write lattice.\n\n");
    exit(0);
  }


CloseShop:

  /*
   * Free allocated memory:
   */
printf("Freeing memory...\n");
  lfreelt(lat);
  free((LATTICE_DATA_TYPE *)lattice1);
  free((float *)fft_data);

  /*
   * Close files:
   */
printf("Closing files...\n");
  fclose(latticein1);
  fclose(latticein2);
  fclose(latticeout1);
  fclose(latticeout2);
}


::::::::::::::
fftlt.c
::::::::::::::
/* FFTLT.C - Calculate the fft of a lattice.

   Author: Mike Wall
   Date: 2/28/95
   Version: 1.

   Usage:
   		"fftlt <real input lattice> <imaginary input lattice>
		<real FFT lattice> <imaginary FFT lattice> <isign>"

		Input is real and imaginary lattice.  Output is FFT of lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2,
    *latticeout1,
    *latticeout2;

  char
    error_msg[LINESIZE];

  LAT3D







Sep 19 20:37 1995   Page 63


    *lat;

  LATTICE_DATA_TYPE
    *lattice1,
    *lattice2;

  float
    inverse_scale = 262144.,
    *fft_data;

  size_t
    fft_index,
    lat_index,
    i,
    j,
    k;

  int
    imaginput = 0,
    nn[4],
    ndim = 3,
    isign = 1;
/*
 * Set input line defaults:
 */
	
  latticein1 = stdin;
  latticein2 = stdin;
  latticeout1 = stdout;
  latticeout2 = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 6:
	  isign = atoi(argv[5]);
	  case 5:
	  if (strcmp(argv[4],"-") == 0) {
	    latticeout2 = stdout;
	  }
	  else {
	    if ((latticeout2 = fopen(argv[4],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[4]);
	      exit(0);
	    }
	  }
	  case 4:
	  if (strcmp(argv[3],"-") == 0) {
	    latticeout1 = stdout;
	  }
	  else {
	    if ((latticeout1 = fopen(argv[3],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[3]);
	      exit(0);
	    }







Sep 19 20:37 1995   Page 64


	  }
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    imaginput = 0;
	  }
	  else {
	    if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[2]);
	      exit(0);
	    }
	    imaginput = 1;
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein1 = stdin;
	  }
	  else {
	    if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: fftlt <input real lattice> <input imag lattice>"
		 "<output real lattice> <output imag lattice> <isign>\n\n");
	  exit(0);
	}

  /*
   * Initialize lattices:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in real lattice:
   */

  lat->infile = latticein1;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }
  lattice1 = lat->lattice;

  /*
   * Read in imageinary lattice if on input line;  Otherwise, set it
   * to zero:
   */

  if(imaginput) {
    lat->lattice = NULL;







Sep 19 20:37 1995   Page 65


    lat->infile = latticein2;
    if (lreadlt(lat) != 0) {
      perror("Couldn't read lattice.\n\n");
      exit(0);
    }
    lattice2 = lat->lattice;
  } else {
    lattice2 = (LATTICE_DATA_TYPE *)calloc(lat->lattice_length,
					   sizeof(LATTICE_DATA_TYPE));
  }

  /*
   * Allocate memory for fft data array:
   */

  fft_data = (float *)calloc(64*64*64*2+1,sizeof(float));
  if (!fft_data) {
    perror("Couldn't allocate fft data array.\n\n");
    exit(0);
  }

  /*
   * Prepare lattice for fft:
   */

printf("Preparing lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  for(i=0;i<64;i++) {
    for(j=0;j<64;j++) {
      for(k=0;k<64;k++) {
	lat_index = 4096*((k+31)%64) + 64*((j+31)%64) + (i+31)%64;
	fft_data[fft_index] = (float)lattice1[lat_index];
	fft_data[fft_index+1] = (float)lattice2[lat_index];
/*
 * Convert ignore_tags to zeroes:
 */
	if (fft_data[fft_index] == (float)lat->mask_tag)
	  fft_data[fft_index] = 0;
	if (fft_data[fft_index+1] == (float)lat->mask_tag)
	  fft_data[fft_index+1] = 0;
	fft_index = fft_index + 2;
	/*printf("%d,%d,%d: %f\n",i,j,k,fft_data[fft_index-2]);/***/
      }
    }
  }
printf("...done.\n");/***/
  /*
   * Calculate FFT :
   */

  nn[1] = 64;
  nn[2] = 64;
  nn[3] = 64;
printf("Entering FFT...\n");
  lfft(fft_data,nn,ndim,isign);
printf("...done.\n");







Sep 19 20:37 1995   Page 66


  /*
   * Extract lattice from fft data array -- take magnitude.
   */

printf("Extracting lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  lat_index = 0;
  for(i=0;i<64;i++) {
    for(j=0;j<64;j++) {
      for(k=0;k<64;k++) {
	lat_index = 4096*((k+31)%64) + 64*((j+31)%64) + (i+31)%64;
	if (isign == -1) {
	  lattice1[lat_index] = 1./inverse_scale *
	    (LATTICE_DATA_TYPE)fft_data[fft_index];
	  lattice2[lat_index] = 1./inverse_scale *
	    (LATTICE_DATA_TYPE)fft_data[fft_index+1];
	} else {
	  lattice1[lat_index] = (LATTICE_DATA_TYPE)fft_data[fft_index];
	  lattice2[lat_index] = (LATTICE_DATA_TYPE)fft_data[fft_index+1];
	}
	fft_index = fft_index + 2;
      }
    }
  }
printf("...done. fft_index = %d,%d\n",fft_index,lat_index);

  /*
   * Prepare lattice for output:
   */

  lat->xscale = 1./lat->xscale*1/64.;
  lat->yscale = 1./lat->yscale*1/64.;
  lat->zscale = 1./lat->zscale*1/64.;
  lat->xbound.min = - (LATTICE_DATA_TYPE)(lat->origin.i*lat->xscale);
  lat->xbound.max = (LATTICE_DATA_TYPE)((lat->xvoxels -
					lat->origin.i - 1)*lat->xscale);
  lat->ybound.min = - (LATTICE_DATA_TYPE)(lat->origin.j*lat->yscale);
  lat->ybound.max = (LATTICE_DATA_TYPE)((lat->yvoxels -
					lat->origin.j - 1)*lat->yscale);
  lat->zbound.min = - (LATTICE_DATA_TYPE)(lat->origin.i*lat->zscale);
  lat->zbound.max = (LATTICE_DATA_TYPE)((lat->zvoxels -
					lat->origin.k - 1)*lat->zscale);

  /*
   * Write lattices to output file:
   */
printf("Writing lattice...\n");/***/
  lat->lattice = lattice1;
  lat->outfile = latticeout1;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

printf("Writing lattice...\n");/***/
  lat->lattice = lattice2;







Sep 19 20:37 1995   Page 67


  lat->outfile = latticeout2;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }


CloseShop:

  /*
   * Free allocated memory:
   */
printf("Freeing memory...\n");
  lfreelt(lat);
  free((LATTICE_DATA_TYPE *)lattice1);
  free((float *)fft_data);

  /*
   * Close files:
   */
printf("Closing files...\n");
  fclose(latticein1);
  fclose(latticein2);
  fclose(latticeout1);
  fclose(latticeout2);
}


::::::::::::::
filter.c
::::::::::::::
/* FILTER.C - Select data points from a list which match another in
   the x-coordinate.

   Author: Mike Wall
   Date: 12/31/94
   Version: 1.0

   "filter <input list 1> <input list 2> <output list>"

   Input is two (x,y) lists.  Output is (x,y) of the second which have x2=x1.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *infile1,
    *infile2,
    *outfile;

  size_t
    i;








Sep 19 20:37 1995   Page 68


  char
    input_line[LINESIZE],
    *end_of_file;

  float
    x1,
    y1,
    x2,
    y2;

  /*
   * Set input line defaults:
   */

  infile1 = stdin;
  infile2 = stdin;
  outfile = stdout;

  /*
   * Read information from input line:
   */

  switch(argc) {
    case 4:
    if (strcmp(argv[3], "-") == 0) {
      outfile = stdout;
    }
    else {
      if ( (outfile = fopen(argv[3],"wb")) == NULL ) {
	printf("Can't open %s.",argv[3]);
	exit(0);
      }
    }
    case 3:
    if (strcmp(argv[2], "-") == 0) {
      infile2 = stdin;
    }
    else {
      if ( (infile2 = fopen(argv[2],"rb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }
    }
    case 2:
    if ( (infile1 = fopen(argv[1],"rb")) == NULL ) {
      printf("Can't open %s.",argv[1]);
      exit(0);
    }
    break;
    default:
    printf("\n Usage: filter <input list 1> "
	   "<input list 2> <output list>\n\n");
    exit(0);
  }

  /*







Sep 19 20:37 1995   Page 69


   * Read in lists; output selectively:
   */

  while(fgets(input_line,LINESIZE,infile1) != NULL) {
    sscanf(input_line,"%g %g",&x1,&y1);
    do {
      end_of_file = fgets(input_line,LINESIZE,infile2);
      sscanf(input_line,"%g %g",&x2,&y2);
    } while ((x1 != x2) && (end_of_file != NULL));
    fprintf(outfile,"%e %e\n",x2,y2);
  }

  /*
   * Close files:
   */

  fclose(infile1);
  fclose(infile2);
  fclose(outfile);

}



::::::::::::::
ftfltim.c
::::::::::::::
/* FTFLTIM.C - Fourier-transform filter an image.

   Author: Mike Wall
   Date: 4/7/95
   Version: 1.

   Usage:
   		"ftfltim <input image> <output image> <length scale>"

		Input is image.  Output is FT filtered image.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *imagein1,
    *imageout1;

  char
    error_msg[LINESIZE];

  DIFFIMAGE
    *imdiff;

  IMAGE_DATA_TYPE
    *image1;








Sep 19 20:37 1995   Page 70


  float
    inverse_scale = 1048576.,
    *fimage1,
    *fimage2,
    *fft_data;

  size_t
    fft_index,
    image_index,
    i,
    j,
    k;

  int
    range,
    length_scale,
    imaginput = 0,
    nn[3],
    ndim = 2,
    isign = 1;
/*
 * Set input line defaults:
 */
	
  imagein1 = stdin;
  imageout1 = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 4:
	  length_scale = atoi(argv[3]);
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    imageout1 = stdout;
	  }
	  else {
	    if ((imageout1 = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    imagein1 = stdin;
	  }
	  else {
	    if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: ftfltim <input image> "







Sep 19 20:37 1995   Page 71


		 "<output image> <length_scale>\n\n");
	  exit(0);
	}

  /*
   * Initialize images:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize image.\n\n");
    exit(0);
  }

  /*
   * Read in real image:
   */

  imdiff->infile = imagein1;
  if (lreadim(imdiff) != 0) {
    perror("Couldn't read image.\n\n");
    exit(0);
  }
  image1 = imdiff->image;


  /*
   * Allocate memory for fft data array and intermediate floating
   *  point images:
   */

  fft_data = (float
	      *)calloc((imdiff->image_length+1)*2,sizeof(float));
  fimage1 = (float *)calloc(imdiff->image_length+1,sizeof(float));
  fimage2 = (float *)calloc(imdiff->image_length+1,sizeof(float));
  if (!fft_data || !fimage1 || !fimage2) {
    perror("Couldn't allocate fft data arrays.\n\n");
    exit(0);
  }

  /*
   * Prepare image for fft:
   */

  printf("Preparing lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  for(i=0;i<imdiff->vpixels;i++) {
    for(j=0;j<imdiff->hpixels;j++) {
      image_index =
	imdiff->hpixels*((j+imdiff->vpixels/2)%imdiff->vpixels) +
	  (i+imdiff->hpixels/2)%imdiff->hpixels;
      fft_data[fft_index] = (float)image1[image_index];
      fft_data[fft_index+1] = 0;
      fft_index = fft_index + 2;
    }
    /*printf("%d,%d,%d: %f\n",i,j,k,fft_data[fft_index-2]);/***/
  }







Sep 19 20:37 1995   Page 72


  printf("...done.\n");/***/
  /*
   * Calculate FFT :
   */

  nn[1] = 1024;
  nn[2] = 1024;
  isign=1;
  printf("Entering FFT...\n");
  lfft(fft_data,nn,ndim,isign);
  printf("...done.\n");
  /*
   * Extract lattice from fft data array -- take magnitude.
   */

  printf("Extracting lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  for(i=0;i<imdiff->vpixels;i++) {
    for(j=0;j<imdiff->hpixels;j++) {
      image_index =
	imdiff->hpixels*((j+imdiff->vpixels/2)%imdiff->vpixels) +
	  (i+imdiff->hpixels/2)%imdiff->hpixels;
      fimage1[image_index] = fft_data[fft_index];
      fimage2[image_index] = fft_data[fft_index+1];
      fft_index = fft_index+2;
    }
  }
printf("...done. fft_index = %d,%d\n",fft_index,image_index);

  /*
   * Window the FFT:
   */

printf("Window...\n");
  image_index = 0;
  range = imdiff->vpixels / length_scale;
  for(i=0;i<imdiff->vpixels;i++){
    for(j=0;j<imdiff->hpixels;j++) {
      if ((abs(i-512) > range) && (abs(j-512) > range)) {
	fimage1[image_index] = 0;
	fimage2[image_index] = 0;
      }
      image_index++;
    }
  }
printf("...done\n");

  /*
   * Prepare image for fft:
   */

  printf("Preparing lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  for(i=0;i<imdiff->vpixels;i++) {
    for(j=0;j<imdiff->hpixels;j++) {
      image_index =







Sep 19 20:37 1995   Page 73


	imdiff->hpixels*((j+imdiff->vpixels/2)%imdiff->vpixels) +
	  (i+imdiff->hpixels/2)%imdiff->hpixels;
      fft_data[fft_index] = fimage1[image_index];
      fft_data[fft_index+1] = fimage2[image_index];
      fft_index = fft_index + 2;
    }
    /*printf("%d,%d,%d: %f\n",i,j,k,fft_data[fft_index-2]);/***/
  }
printf("...done.\n");/***/

  /*
   * Calculate FFT :
   */

  nn[1] = 1024;
  nn[2] = 1024;
  isign=-1;
printf("Entering FFT...\n");
  lfft(fft_data,nn,ndim,isign);
printf("...done.\n");

  /*
   * Extract lattice from fft data array -- take magnitude.
   */

printf("Extracting lattice...\n");/***/
  fft_index = 1; /* Data array starts at position 1 */
  for(i=0;i<imdiff->vpixels;i++) {
    for(j=0;j<imdiff->hpixels;j++) {
      image_index =
	imdiff->hpixels*((j+imdiff->vpixels/2)%imdiff->vpixels) +
	  (i+imdiff->hpixels/2)%imdiff->hpixels;
      image1[image_index] = (IMAGE_DATA_TYPE)(1./inverse_scale*
					      fft_data[fft_index]);
      fft_index = fft_index+2;
    }
  }
printf("...done. fft_index = %d,%d\n",fft_index,image_index);

  /*
   * Write image to output file:
   */
printf("Writing images...\n");/***/
  imdiff->image = image1;
  imdiff->outfile = imageout1;
  if (lwriteim(imdiff) != 0) {
    perror("Couldn't write image.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */
printf("Freeing memory...\n");







Sep 19 20:37 1995   Page 74


  lfreeim(imdiff);
  free((float *)fft_data);
  free((float *)fimage1);
  free((float *)fimage2);

  /*
   * Close files:
   */
printf("Closing files...\n");
  fclose(imagein1);
  fclose(imageout1);
}


::::::::::::::
gausslt.c
::::::::::::::
/* GAUSSLT.C - Generate a gaussian lattice.

   Author: Mike Wall
   Date: 2/28/95
   Version: 1.

   Usage:
   		"gausslt <input lattice> <output lattice> <peak> <width>"

		Input is lattice.  Output is FFT of lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *latticeout;

  char
    error_msg[LINESIZE];

  LAT3D
    *lat;

  float
    peak,
    width;

/*
 * Set input line defaults:
 */
	
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:







Sep 19 20:37 1995   Page 75


 */
	switch(argc) {
	  case 5:
	  width = atof(argv[4]);
	  case 4:
	  peak = atof(argv[3]);
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    latticeout = stdout;
	  }
	  else {
	    if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: gausslt <input lattice> "
		 "<output lattice> <peak> <width>\n\n");
	  exit(0);
	}

  /*
   * Initialize lattices:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  /*
   * Calculate gaussian :
   */








Sep 19 20:37 1995   Page 76


  lat->width = width;
  lat->peak = peak;
  lgausslt(lat);

  /*
   * Write lattice to output file:
   */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(latticeout);
}


::::::::::::::
gencmd.c
::::::::::::::
#include<stdio.h>

void main(void)
{
	short i;

	for (i=0;i<=196;i++) {
		printf("dd if=/dev/nrtapensv of=lysh%d.tif bs=2101248\n",i);
	}
}

::::::::::::::
genlat.c
::::::::::::::
/* GENLAT.C - Create a 3D lattice based upon an input list of
              diffraction images and index files.

   Author: Mike Wall
   Date: 2/22/95
   Version: 1.

   Usage:







Sep 19 20:37 1995   Page 77



   "genlat <output file > <inner radius cutoff> <outer radius cutoff>
   <x-origin> <y-origin> <z-origin> <minrange>"

      A list in the form of:

      <index file> <image file> <scale factor>

      must be supplied at standard input, terminated by '.' in the
      first character of the last line.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *infile,
    *outfile,
    *imagein;

  char
    *info_string,
    *space_ptr,
    input_line[LINESIZE],
    error_msg[LINESIZE];

  size_t
    *ct,
    num_values,
    num_wrote,
    num_read,
    map_index,
    index,
    i,
    j,
    k;

  int
    hh,
    kk,
    ll;

  DIFFIMAGE
    *imdiff;

  LAT3D
    *lat;

  struct voxel
    *map3D,
    *voxel_data;

  struct xyzcoords
    dist,







Sep 19 20:37 1995   Page 78


    pos;

  float
    cell_a,
    cell_b,
    cell_c,
    cell_alpha,
    cell_beta,
    cell_gamma,
    distance,
    x_beam,
    y_beam,
    minrange,
    q_squared,
    inner_radius,
    inner_radius_sq,
    outer_radius,
    outer_radius_sq,
    scale;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  origin.i = origin.j = origin.k = DEFAULT_LATTICE_ORIGIN;
  scale=1;
  outfile = stdout;
  inner_radius= DEFAULT_INNER_RADIUS_LT;
  outer_radius = DEFAULT_OUTER_RADIUS_LT;
  inner_radius_sq = inner_radius*inner_radius;
  outer_radius_sq = DEFAULT_BOUND_MAX*DEFAULT_BOUND_MAX;
  origin.i = origin.j = origin.k = DEFAULT_LATTICE_ORIGIN;
  x_beam = DEFAULT_X_BEAM;
  y_beam = DEFAULT_Y_BEAM;
  distance = DEFAULT_DISTANCE_MM;
  switch(argc) {
    case 17:
    cell_gamma = atof(argv[16]);
    case 16:
    cell_beta = atof(argv[15]);
    case 15:
    cell_alpha = atof(argv[14]);
    case 14:
    cell_c = atof(argv[13]);
    case 13:
    cell_b = atof(argv[12]);
    case 12:
    cell_a = atof(argv[11]);
    case 11:
    distance = atof(argv[10]);
    case 10:
    y_beam = atof(argv[9]);
    case 9:







Sep 19 20:37 1995   Page 79


    x_beam = atof(argv[8]);
    case 8:
    minrange = atof(argv[7]);
    case 7:
    origin.k = atol(argv[6]);
    case 6:
    origin.j = atol(argv[5]);
    case 5:
    origin.i = atol(argv[4]);
    case 4:
    outer_radius = atof(argv[3]);
    outer_radius_sq = outer_radius*outer_radius;
    case 3:
    inner_radius = atof(argv[2]);
    inner_radius_sq = inner_radius*inner_radius;
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      outfile = stdout;
    }
    else {
      if ( (outfile = fopen(argv[1],"wb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: genlat <output file> <inner radius> "
	   "<outer radius> <x-origin> <y-origin> <z-origin>"
	   " <minrange> <x beam> <y beam> <distance>\n\n"
           " A list in the form of:\n\n"
           "   <index file> <image file> <scale factor>\n\n"
           " must be supplied at standard input, terminated by '.' in the\n"
           " first character of the last line.\n\n");
    exit(0);
  }

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }


  /*
   * Allocate memory:
   */

  map3D = (struct voxel *)malloc(sizeof(struct voxel)*imdiff->image_length);
  if (!map3D) {
    printf("\n***Unable to allocate map3D.\n");
    goto CloseShop;
  }







Sep 19 20:37 1995   Page 80



  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.n\n");
    exit(0);
  }



  /*
   * Set main defaults:
   */

  lat->map3D = map3D;
  lat->minrange.x = lat->minrange.y = lat->minrange.z = minrange;
  lat->origin = origin;
  lat->xbound.min = - lat->origin.i*lat->xscale;
  lat->xbound.max = (lat->xvoxels - lat->origin.i - 1)*lat->xscale;
  lat->ybound.min = - lat->origin.j*lat->yscale;
  lat->ybound.max = (lat->yvoxels - lat->origin.j - 1)*lat->yscale;
  lat->zbound.min = - lat->origin.k*lat->zscale;
  lat->zbound.max = (lat->zvoxels - lat->origin.k - 1)*lat->zscale;
  lat->cell.a = cell_a;
  lat->cell.b = cell_b;
  lat->cell.c = cell_c;
  lat->cell.alpha = cell_alpha;
  lat->cell.beta = cell_beta;
  lat->cell.gamma = cell_gamma;
  imdiff->beam_mm.x = x_beam;
  imdiff->beam_mm.y = y_beam;
  imdiff->distance_mm = distance;

  /*
   * Allocate ct:
   */

  ct = (size_t *)calloc(lat->lattice_length,sizeof(size_t));
  if (!ct) {
    printf("\nNot enough room to allocate counting table ct.\n\n");
    exit(0);
  }

  /*
   * Loop through input lines until '.' is encountered.
   */

  while ((*gets(input_line) != '.') && (input_line != NULL)) {
    printf("%s\n",input_line);
    info_string = input_line;
    space_ptr = strchr(info_string,' ');
    *space_ptr = 0;
    if ( (infile = fopen(info_string,"r")) == NULL ) {
      printf("\nCan't open index file %s.\n\n",info_string);







Sep 19 20:37 1995   Page 81


      exit(0);
    }
    info_string = space_ptr+1;
    space_ptr = strchr(info_string,' ');
    *space_ptr = 0;
    if ( (imagein = fopen(info_string,"rb")) == NULL ) {
      printf("\nCan't open image %s.\n\n",info_string);
      exit(0);
    }
    info_string = space_ptr+1;
    if (info_string != "") {
      scale = atof(info_string);
    } else {
      scale = 1.;
    }

    /*
     * Read input file which contains the orientation matrix:
     */

    imdiff->infile = infile;
    lgetmat(imdiff);

    /*
     * Read diffraction image:
     */

    imdiff->infile = imagein;
    if (lreadim(imdiff) != 0) {
      perror(imdiff->error_msg);
      goto CloseShop;
    }

    /*
     * Step through the image and generate the map:
     */

    map_index = 0;
    for (i=0; i<imdiff->vpixels; i++) {
      imdiff->pos.r = i;
      for (j=0; j<imdiff->hpixels; j++) {
	imdiff->pos.c = j;
	imdiff->map3D = &map3D[map_index];
	lgensv(imdiff);
	map_index++;
      }
    }

    /*
     * Scale the values to the input line scale:
     */

    for(map_index=0; map_index<imdiff->image_length; map_index++) {
      map3D[map_index].value *= scale;
    }








Sep 19 20:37 1995   Page 82


    /*
     * Step through the map and fill the lattice:
     */

    for(map_index=0; map_index<imdiff->image_length; map_index++) {
      voxel_data = &map3D[map_index];
/*printf("%d : %f, %f, %f, %f\n",map_index,voxel_data->pos.x,voxel_data->pos.y,voxel_data->pos.z,voxel_data->value);/***/
      q_squared = (voxel_data->pos.x*voxel_data->pos.x +
		   voxel_data->pos.y*voxel_data->pos.y +
		   voxel_data->pos.z*voxel_data->pos.z);
      if ((inner_radius_sq < q_squared) && (outer_radius_sq >
					    q_squared)) {
	if (voxel_data->pos.x < 0) {
	  hh = (int)(voxel_data->pos.x - .5);
	} else {
	  hh = (int)(voxel_data->pos.x + .5);
	}
	if (voxel_data->pos.y < 0) {
	  kk = (int)(voxel_data->pos.y - .5);
	} else {
	  kk = (int)(voxel_data->pos.y + .5);
	}
	if (voxel_data->pos.z < 0) {
	  ll = (int)(voxel_data->pos.z - .5);
	} else {
	  ll = (int)(voxel_data->pos.z + .5);
	}
	i = (size_t) (voxel_data->pos.x + lat->origin.i + .5);
	j = (size_t) (voxel_data->pos.y + lat->origin.j + .5);
	k = (size_t) (voxel_data->pos.z + lat->origin.k + .5);
	dist.x = (float)fabsf(voxel_data->pos.x - (float)hh);
	dist.y = (float)fabsf(voxel_data->pos.y - (float)kk);
	dist.z = (float)fabsf(voxel_data->pos.z - (float)ll);
	if ((voxel_data->value != lat->mask_tag) &&
	    (voxel_data->value != 0) &&
	    (dist.x > lat->minrange.x) &&
	    (dist.y > lat->minrange.y) &&
	    (dist.z > lat->minrange.z)) {
	  index = k*lat->xyvoxels + j*lat->xvoxels + i;
	  if (index >= lat->lattice_length) {
	    printf("\nTried to index lattice outside of range.\n");
	    goto CloseShop;
	  }
	  if (ct[index] == 0) {
	    lat->lattice[index] = (LATTICE_DATA_TYPE)voxel_data->value;
	    ct[index]++;
	  } else {
	    lat->lattice[index] =
	      (LATTICE_DATA_TYPE)(((float)ct[index]*lat->lattice[index] +
				   voxel_data->value)
				  /(float)(ct[index]+1.));
	    ct[index]++;
	  }
	}
      }
    }







Sep 19 20:37 1995   Page 83



    /*
     * Close input files:
     */

    fclose(infile);
    fclose(imagein);
  }

  /*
   * Write lattice to output file:
   */

  lat->outfile = outfile;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);
  lfreelt(lat);
  free((struct voxel *)map3D);
  free((size_t *)ct);

  /*
   * Close files:
   */

  fclose(outfile);
}


::::::::::::::
genlat.new.c
::::::::::::::
/* GENLAT.C - Create a 3D lattice based upon an input list of
              diffraction images and index files.

   Author: Mike Wall
   Date: 2/22/95
   Version: 1.

   Usage:

   "genlat <output file > <inner radius cutoff> <outer radius cutoff>"

      A list in the form of:

      <index file> <image file> <scale factor>








Sep 19 20:37 1995   Page 84


      must be supplied at standard input, terminated by '.' in the
      first character of the line.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *infile,
    *outfile,
    *imagein;

  char
    *info_string,
    *space_ptr,
    input_line[LINESIZE],
    error_msg[LINESIZE];

  size_t
    *ct,
    num_values,
    num_wrote,
    num_read,
    map_index,
    index,
    i,
    j,
    k,
    xyvoxels;

  DIFFIMAGE
    *imdiff;

  LAT3D
    *lat;

  struct voxel
    *map3D,
    *voxel_data;

  struct xyzcoords
    dist,
    pos;

  float
    q_squared,
    inner_radius,
    inner_radius_sq,
    outer_radius,
    outer_radius_sq,
    scale;

  double
    xscale,







Sep 19 20:37 1995   Page 85


    yscale,
    zscale;


  /*
   * Set input line defaults:
   */

  scale=1;
  outfile = stdout;
  inner_radius= DEFAULT_INNER_RADIUS_LT;
  outer_radius = DEFAULT_OUTER_RADIUS_LT;
  inner_radius_sq = inner_radius*inner_radius;
  outer_radius_sq = DEFAULT_BOUND_MAX*DEFAULT_BOUND_MAX;

  switch(argc) {
    case 4:
    outer_radius = atof(argv[3]);
    outer_radius_sq = outer_radius*outer_radius;
    case 3:
    inner_radius = atof(argv[2]);
    inner_radius_sq = inner_radius*inner_radius;
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      outfile = stdout;
    }
    else {
      if ( (outfile = fopen(argv[1],"wb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: genlat <output file> \n\n");
    exit(0);
  }
/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }


  /*
   * Allocate memory:
   */

  map3D = (struct voxel *)malloc(sizeof(struct voxel)*imdiff->image_length);
  lat = (LAT3D *)malloc(sizeof(LAT3D));
  if (!lat || !map3D) {
    printf("\n***Unable to allocate all memory.\n");
    goto CloseShop;







Sep 19 20:37 1995   Page 86


  }

  /*
   * Set main defaults:
   */

  lat->map3D = map3D;
  lat->mask_tag = PUNCH_TAG;
  lat->xvoxels = DEFAULT_XVOXELS;
  lat->yvoxels = DEFAULT_YVOXELS;
  lat->zvoxels = DEFAULT_ZVOXELS;
  lat->xbound.min = DEFAULT_BOUND_MIN;
  lat->xbound.max = DEFAULT_BOUND_MAX;
  lat->ybound.min = DEFAULT_BOUND_MIN;
  lat->ybound.max = DEFAULT_BOUND_MAX;
  lat->zbound.min = DEFAULT_BOUND_MIN;
  lat->zbound.max = DEFAULT_BOUND_MAX;
  lat->minrange.x = DEFAULT_MINRANGE;
  lat->minrange.y = DEFAULT_MINRANGE;
  lat->minrange.z = DEFAULT_MINRANGE;
  xscale = (double)(lat->xvoxels-1) /
    (lat->xbound.max - lat->xbound.min);
  yscale = (double)(lat->yvoxels-1) /
    (lat->ybound.max - lat->ybound.min);
  zscale = (double)(lat->zvoxels-1) /
    (lat->zbound.max - lat->zbound.min);
  xyvoxels = lat->xvoxels * lat->yvoxels;

  /*
   * Allocate lattice and ct:
   */

  lat->lattice_length = xyvoxels*lat->zvoxels;
  lat->lattice = (LATTICE_DATA_TYPE *)calloc(lat->lattice_length,
					     sizeof(LATTICE_DATA_TYPE));
  ct = (size_t *)calloc(lat->lattice_length,sizeof(size_t));
  if (!lat->lattice || !ct) {
    printf("\nNot enough room to allocate 3D lattice and counting table.\n\n");
    exit(0);
  }

  /*
   * Loop through input lines until '.' is encountered.
   */

  while ((*gets(input_line) != '.') && (input_line != NULL)) {
    printf("%s\n",input_line);
    info_string = input_line;
    space_ptr = strchr(info_string,' ');
    *space_ptr = 0;
    if ( (infile = fopen(info_string,"r")) == NULL ) {
      printf("\nCan't open index file %s.\n\n",info_string);
      exit(0);
    }
    info_string = space_ptr+1;
    space_ptr = strchr(info_string,' ');







Sep 19 20:37 1995   Page 87


    *space_ptr = 0;
    if ( (imagein = fopen(info_string,"rb")) == NULL ) {
      printf("\nCan't open image %s.\n\n",info_string);
      exit(0);
    }
    info_string = space_ptr+1;
    if (info_string != "") {
      scale = atof(info_string);
    } else {
      scale = 1.;
    }

    /*
     * Read input file which contains the orientation matrix:
     */

    imdiff->infile = infile;
    lgetmat(imdiff);

    /*
     * Read diffraction image:
     */

    imdiff->infile = imagein;
    if (lreadim(imdiff) != 0) {
      perror(imdiff->error_msg);
      goto CloseShop;
    }

    /*
     * Step through the image and generate the map:
     */

    map_index = 0;
    for (i=0; i<imdiff->vpixels; i++) {
      imdiff->pos.r = i;
      for (j=0; j<imdiff->hpixels; j++) {
	imdiff->pos.c = j;
	imdiff->map3D = &map3D[map_index];
	lgensv(imdiff);
	map_index++;
      }
    }

    /*
     * Scale the values to the input line scale:
     */

    for(map_index=0; map_index<imdiff->image_length; map_index++) {
      map3D[map_index].value *= scale;
    }

    /*
     * Step through the map and fill the lattice:
     */








Sep 19 20:37 1995   Page 88


    for(map_index=0; map_index<imdiff->image_length; map_index++) {
      voxel_data = &map3D[map_index];
/*printf("%d : %f, %f, %f, %f\n",map_index,voxel_data->pos.x,voxel_data->pos.y,voxel_data->pos.z,voxel_data->value);/***/
      q_squared = (voxel_data->pos.x*voxel_data->pos.x +
		   voxel_data->pos.y*voxel_data->pos.y +
		   voxel_data->pos.z*voxel_data->pos.z);
      if ((inner_radius_sq < q_squared) && (outer_radius_sq >
					    q_squared)) {
	if (voxel_data->pos.x < 0) {
	  pos.x = voxel_data->pos.x - .5;
	} else {}
	  pos.x = voxel_data->pos.x + .5;
	
	if (voxel_data->pos.y < 0) {
	  pos.y = voxel_data->pos.y - .5;
	} else {
	  pos.y = voxel_data->pos.y + .5;
	}
	if (voxel_data->pos.z < 0) {
	  pos.z = voxel_data->pos.z - .5;
	} else {
	  pos.z = voxel_data->pos.z + .5;
	}
	i = (size_t) ((pos.x - lat->xbound.min)*xscale );
	j = (size_t) ((pos.y - lat->ybound.min)*yscale );
	k = (size_t) ((pos.z - lat->zbound.min)*zscale );
	dist.x = (float)fabsf(pos.x - (float)i);
	dist.y = (float)fabsf(pos.y - (float)j);
	dist.z = (float)fabsf(pos.z - (float)k);
	if ((voxel_data->value != lat->mask_tag) &&
	    (voxel_data->value != 0)) {
/*	    (dist.x > lat->minrange.x) &&
	    (dist.y > lat->minrange.y) &&
	    (dist.z > lat->minrange.z))
*/
	  index = k*xyvoxels + j*lat->xvoxels + i;
	  if (index >= lat->lattice_length) {
	    printf("\nTried to index lattice outside of range.\n");
	    goto CloseShop;
	  }
	  if (ct[index == 0]) {
	    lat->lattice[index] = (LATTICE_DATA_TYPE)voxel_data->value;
	    ct[index]++;
	  } else {
	    lat->lattice[index] =
	      (LATTICE_DATA_TYPE)(((float)ct[index]*lat->lattice[index] +
				   voxel_data->value)
				  /(float)(ct[index]+1.));
	    ct[index]++;
	  }
	}
      }
    }

    /*
     * Close input files:







Sep 19 20:37 1995   Page 89


     */

    fclose(infile);
    fclose(imagein);
  }

  /*
   * Write header info for lattice:
   */

  fwrite(&lat->xvoxels, sizeof(long), 1, outfile);
  fwrite(&lat->yvoxels, sizeof(long), 1, outfile);
  fwrite(&lat->zvoxels, sizeof(long), 1, outfile);
  fwrite(&lat->xbound, sizeof(struct bounds), 1, outfile);
  fwrite(&lat->ybound, sizeof(struct bounds), 1, outfile);
  fwrite(&lat->zbound, sizeof(struct bounds), 1, outfile);

  /*
   * Write lattice to output file:
   */

  num_wrote = fwrite(lat->lattice, sizeof(LATTICE_DATA_TYPE),
		     lat->lattice_length, outfile);
  if (num_wrote != lat->lattice_length) {
    printf("\nCouldn't write output file.\n\n");
    goto CloseShop;
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);
  free((LATTICE_DATA_TYPE *)lat->lattice);
  free((LAT3D *)lat);
  free((struct voxel *)map3D);
  free((size_t *)ct);

  /*
   * Close files:
   */

  fclose(outfile);
}

::::::::::::::
genlat.tmp.c
::::::::::::::
/* GENLAT.C - Create a 3D lattice based upon an input list of
              diffraction images and index files.

   Author: Mike Wall
   Date: 2/22/95
   Version: 1.







Sep 19 20:37 1995   Page 90



   Usage:

   "genlat <output file > <inner radius cutoff> <outer radius cutoff> <minrange>"

      A list in the form of:

      <index file> <image file> <scale factor>

      must be supplied at standard input, terminated by '.' in the
      first character of the line.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *infile,
    *outfile,
    *imagein;

  char
    *info_string,
    *space_ptr,
    input_line[LINESIZE],
    error_msg[LINESIZE];

  size_t
    *ct,
    num_values,
    num_wrote,
    num_read,
    map_index,
    index,
    i,
    j,
    k;

  int
    hh,
    kk,
    ll;

  DIFFIMAGE
    *imdiff;

  LAT3D
    *lat;

  struct voxel
    *map3D,
    *voxel_data;

  struct xyzcoords







Sep 19 20:37 1995   Page 91


    dist,
    pos;

  float
    minrange,
    q_squared,
    inner_radius,
    inner_radius_sq,
    outer_radius,
    outer_radius_sq,
    scale;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  origin.i = origin.j = origin.k = DEFAULT_LATTICE_ORIGIN;
  scale=1;
  outfile = stdout;
  inner_radius= DEFAULT_INNER_RADIUS_LT;
  outer_radius = DEFAULT_OUTER_RADIUS_LT;
  inner_radius_sq = inner_radius*inner_radius;
  outer_radius_sq = DEFAULT_BOUND_MAX*DEFAULT_BOUND_MAX;

  switch(argc) {
    case 8:
    minrange = atof(argv[7]);
    case 7:
    origin.k = atol(argv[6]);
    case 6:
    origin.j = atol(argv[5]);
    case 5:
    origin.i = atol(argv[4]);
    case 4:
    outer_radius = atof(argv[3]);
    outer_radius_sq = outer_radius*outer_radius;
    case 3:
    inner_radius = atof(argv[2]);
    inner_radius_sq = inner_radius*inner_radius;
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      outfile = stdout;
    }
    else {
      if ( (outfile = fopen(argv[1],"wb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: genlat <output file> <inner radius> "
	   "<outer radius> <minrange>\n\n");







Sep 19 20:37 1995   Page 92


    exit(0);
  }

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }


  /*
   * Allocate memory:
   */

  map3D = (struct voxel *)malloc(sizeof(struct voxel)*imdiff->image_length);
  if (!map3D) {
    printf("\n***Unable to allocate map3D.\n");
    goto CloseShop;
  }

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.n\n");
    exit(0);
  }



  /*
   * Set main defaults:
   */

  lat->map3D = map3D;
  lat->minrange.x = lat->minrange.y = lat->minrange.z = minrange;

  /*
   * Allocate ct:
   */

  ct = (size_t *)calloc(lat->lattice_length,sizeof(size_t));
  if (!ct) {
    printf("\nNot enough room to allocate counting table ct.\n\n");
    exit(0);
  }

  /*
   * Loop through input lines until '.' is encountered.
   */

  while ((*gets(input_line) != '.') && (input_line != NULL)) {







Sep 19 20:37 1995   Page 93


    printf("%s\n",input_line);
    info_string = input_line;
    space_ptr = strchr(info_string,' ');
    *space_ptr = 0;
    if ( (infile = fopen(info_string,"r")) == NULL ) {
      printf("\nCan't open index file %s.\n\n",info_string);
      exit(0);
    }
    info_string = space_ptr+1;
    space_ptr = strchr(info_string,' ');
    *space_ptr = 0;
    if ( (imagein = fopen(info_string,"rb")) == NULL ) {
      printf("\nCan't open image %s.\n\n",info_string);
      exit(0);
    }
    info_string = space_ptr+1;
    if (info_string != "") {
      scale = atof(info_string);
    } else {
      scale = 1.;
    }

    /*
     * Read input file which contains the orientation matrix:
     */

    imdiff->infile = infile;
    lgetmat(imdiff);

    /*
     * Read diffraction image:
     */

    imdiff->infile = imagein;
    if (lreadim(imdiff) != 0) {
      perror(imdiff->error_msg);
      goto CloseShop;
    }

    /*
     * Step through the image and generate the map:
     */

    map_index = 0;
    for (i=0; i<imdiff->vpixels; i++) {
      imdiff->pos.r = i;
      for (j=0; j<imdiff->hpixels; j++) {
	imdiff->pos.c = j;
	imdiff->map3D = &map3D[map_index];
	lgensv(imdiff);
	map_index++;
      }
    }

    /*
     * Scale the values to the input line scale:







Sep 19 20:37 1995   Page 94


     */

    for(map_index=0; map_index<imdiff->image_length; map_index++) {
      map3D[map_index].value *= scale;
    }

    /*
     * Step through the map and fill the lattice:
     */

    for(map_index=0; map_index<imdiff->image_length; map_index++) {
      voxel_data = &map3D[map_index];
/*printf("%d : %f, %f, %f, %f\n",map_index,voxel_data->pos.x,voxel_data->pos.y,voxel_data->pos.z,voxel_data->value);/***/
      q_squared = (voxel_data->pos.x*voxel_data->pos.x +
		   voxel_data->pos.y*voxel_data->pos.y +
		   voxel_data->pos.z*voxel_data->pos.z);
      if ((inner_radius_sq < q_squared) && (outer_radius_sq >
					    q_squared)) {
	if (voxel_data->pos.x < 0) {
	  hh = (int)(voxel_data->pos.x - .5);
	} else {
	  hh = (int)(voxel_data->pos.x + .5);
	}
	if (voxel_data->pos.y < 0) {
	  kk = (int)(voxel_data->pos.y - .5);
	} else {
	  kk = (int)(voxel_data->pos.y + .5);
	}
	if (voxel_data->pos.z < 0) {
	  ll = (int)(voxel_data->pos.z - .5);
	} else {
	  ll = (int)(voxel_data->pos.z + .5);
	}
	i = (size_t) ((pos.x - lat->xbound.min + .5)*lat->xscale );
	j = (size_t) ((pos.y - lat->ybound.min + .5)*lat->yscale );
	k = (size_t) ((pos.z - lat->zbound.min + .5)*lat->zscale );
	dist.x = (float)fabsf(voxel_data->pos.x - (float)hh);
	dist.y = (float)fabsf(voxel_data->pos.y - (float)kk);
	dist.z = (float)fabsf(voxel_data->pos.z - (float)ll);
	if ((voxel_data->value != lat->mask_tag) &&
	    (voxel_data->value != 0) &&
	    (dist.x > lat->minrange.x) &&
	    (dist.y > lat->minrange.y) &&
	    (dist.z > lat->minrange.z)) {
	  index = k*lat->xyvoxels + j*lat->xvoxels + i;
	  if (index >= lat->lattice_length) {
	    printf("\nTried to index lattice outside of range.\n");
	    goto CloseShop;
	  }
	  if (ct[index == 0]) {
	    lat->lattice[index] = (LATTICE_DATA_TYPE)voxel_data->value;
	    ct[index]++;
	  } else {
	    lat->lattice[index] =
	      (LATTICE_DATA_TYPE)(((float)ct[index]*lat->lattice[index] +
				   voxel_data->value)







Sep 19 20:37 1995   Page 95


				  /(float)(ct[index]+1.));
	    ct[index]++;
	  }
	}
      }
    }

    /*
     * Close input files:
     */

    fclose(infile);
    fclose(imagein);
  }

  /*
   * Write lattice to output file:
   */

  lat->outfile = outfile;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);
  lfreelt(lat);
  free((struct voxel *)map3D);
  free((size_t *)ct);

  /*
   * Close files:
   */

  fclose(outfile);
}


::::::::::::::
genlat.works.c
::::::::::::::
/* GENLAT.C - Create a 3D lattice based upon an input list of
              diffraction images and index files.

   Author: Mike Wall
   Date: 2/22/95
   Version: 1.

   Usage:








Sep 19 20:37 1995   Page 96


   "genlat <output file > <inner radius cutoff> <outer radius cutoff> <minrange>"

      A list in the form of:

      <index file> <image file> <scale factor>

      must be supplied at standard input, terminated by '.' in the
      first character of the line.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *infile,
    *outfile,
    *imagein;

  char
    *info_string,
    *space_ptr,
    input_line[LINESIZE],
    error_msg[LINESIZE];

  size_t
    *ct,
    num_values,
    num_wrote,
    num_read,
    map_index,
    index,
    i,
    j,
    k;

  int
    hh,
    kk,
    ll;

  DIFFIMAGE
    *imdiff;

  LAT3D
    *lat;

  struct voxel
    *map3D,
    *voxel_data;

  struct xyzcoords
    dist,
    pos;








Sep 19 20:37 1995   Page 97


  float
    minrange,
    q_squared,
    inner_radius,
    inner_radius_sq,
    outer_radius,
    outer_radius_sq,
    scale;

  /*
   * Set input line defaults:
   */

  scale=1;
  outfile = stdout;
  inner_radius= DEFAULT_INNER_RADIUS_LT;
  outer_radius = DEFAULT_OUTER_RADIUS_LT;
  inner_radius_sq = inner_radius*inner_radius;
  outer_radius_sq = DEFAULT_BOUND_MAX*DEFAULT_BOUND_MAX;

  switch(argc) {
    case 5:
    minrange = atof(argv[4]);
    case 4:
    outer_radius = atof(argv[3]);
    outer_radius_sq = outer_radius*outer_radius;
    case 3:
    inner_radius = atof(argv[2]);
    inner_radius_sq = inner_radius*inner_radius;
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      outfile = stdout;
    }
    else {
      if ( (outfile = fopen(argv[1],"wb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: genlat <output file> <inner radius> "
	   "<outer radius> <minrange>\n\n");
    exit(0);
  }

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }









Sep 19 20:37 1995   Page 98


  /*
   * Allocate memory:
   */

  map3D = (struct voxel *)malloc(sizeof(struct voxel)*imdiff->image_length);
  if (!map3D) {
    printf("\n***Unable to allocate map3D.\n");
    goto CloseShop;
  }

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.n\n");
    exit(0);
  }



  /*
   * Set main defaults:
   */

  lat->map3D = map3D;
  lat->minrange.x = lat->minrange.y = lat->minrange.z = minrange;

  /*
   * Allocate ct:
   */

  ct = (size_t *)calloc(lat->lattice_length,sizeof(size_t));
  if (!ct) {
    printf("\nNot enough room to allocate counting table ct.\n\n");
    exit(0);
  }

  /*
   * Loop through input lines until '.' is encountered.
   */

  while ((*gets(input_line) != '.') && (input_line != NULL)) {
    printf("%s\n",input_line);
    info_string = input_line;
    space_ptr = strchr(info_string,' ');
    *space_ptr = 0;
    if ( (infile = fopen(info_string,"r")) == NULL ) {
      printf("\nCan't open index file %s.\n\n",info_string);
      exit(0);
    }
    info_string = space_ptr+1;
    space_ptr = strchr(info_string,' ');
    *space_ptr = 0;
    if ( (imagein = fopen(info_string,"rb")) == NULL ) {
      printf("\nCan't open image %s.\n\n",info_string);







Sep 19 20:37 1995   Page 99


      exit(0);
    }
    info_string = space_ptr+1;
    if (info_string != "") {
      scale = atof(info_string);
    } else {
      scale = 1.;
    }

    /*
     * Read input file which contains the orientation matrix:
     */

    imdiff->infile = infile;
    lgetmat(imdiff);

    /*
     * Read diffraction image:
     */

    imdiff->infile = imagein;
    if (lreadim(imdiff) != 0) {
      perror(imdiff->error_msg);
      goto CloseShop;
    }

    /*
     * Step through the image and generate the map:
     */

    map_index = 0;
    for (i=0; i<imdiff->vpixels; i++) {
      imdiff->pos.r = i;
      for (j=0; j<imdiff->hpixels; j++) {
	imdiff->pos.c = j;
	imdiff->map3D = &map3D[map_index];
	lgensv(imdiff);
	map_index++;
      }
    }

    /*
     * Scale the values to the input line scale:
     */

    for(map_index=0; map_index<imdiff->image_length; map_index++) {
      map3D[map_index].value *= scale;
    }

    /*
     * Step through the map and fill the lattice:
     */

    for(map_index=0; map_index<imdiff->image_length; map_index++) {
      voxel_data = &map3D[map_index];
/*printf("%d : %f, %f, %f, %f\n",map_index,voxel_data->pos.x,voxel_data->pos.y,voxel_data->pos.z,voxel_data->value);/***/







Sep 19 20:37 1995   Page 100


      q_squared = (voxel_data->pos.x*voxel_data->pos.x +
		   voxel_data->pos.y*voxel_data->pos.y +
		   voxel_data->pos.z*voxel_data->pos.z);
      if ((inner_radius_sq < q_squared) && (outer_radius_sq >
					    q_squared)) {
	if (voxel_data->pos.x < 0) {
	  hh = (int)(voxel_data->pos.x - .5);
	} else {
	  hh = (int)(voxel_data->pos.x + .5);
	}
	if (voxel_data->pos.y < 0) {
	  kk = (int)(voxel_data->pos.y - .5);
	} else {
	  kk = (int)(voxel_data->pos.y + .5);
	}
	if (voxel_data->pos.z < 0) {
	  ll = (int)(voxel_data->pos.z - .5);
	} else {
	  ll = (int)(voxel_data->pos.z + .5);
	}
	i = (size_t) ((pos.x - lat->xbound.min + .5)*lat->xscale );
	j = (size_t) ((pos.y - lat->ybound.min + .5)*lat->yscale );
	k = (size_t) ((pos.z - lat->zbound.min + .5)*lat->zscale );
	dist.x = (float)fabsf(voxel_data->pos.x - (float)hh);
	dist.y = (float)fabsf(voxel_data->pos.y - (float)kk);
	dist.z = (float)fabsf(voxel_data->pos.z - (float)ll);
	if ((voxel_data->value != lat->mask_tag) &&
	    (voxel_data->value != 0) &&
	    (dist.x > lat->minrange.x) &&
	    (dist.y > lat->minrange.y) &&
	    (dist.z > lat->minrange.z)) {
	  index = k*lat->xyvoxels + j*lat->xvoxels + i;
	  if (index >= lat->lattice_length) {
	    printf("\nTried to index lattice outside of range.\n");
	    goto CloseShop;
	  }
	  if (ct[index == 0]) {
	    lat->lattice[index] = (LATTICE_DATA_TYPE)voxel_data->value;
	    ct[index]++;
	  } else {
	    lat->lattice[index] =
	      (LATTICE_DATA_TYPE)(((float)ct[index]*lat->lattice[index] +
				   voxel_data->value)
				  /(float)(ct[index]+1.));
	    ct[index]++;
	  }
	}
      }
    }

    /*
     * Close input files:
     */

    fclose(infile);
    fclose(imagein);







Sep 19 20:37 1995   Page 101


  }

  /*
   * Write lattice to output file:
   */

  lat->outfile = outfile;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);
  lfreelt(lat);
  free((struct voxel *)map3D);
  free((size_t *)ct);

  /*
   * Close files:
   */

  fclose(outfile);
}


::::::::::::::
genmap.c
::::::::::::::
/* GENMAP.C - Create a 3D map of the scattering intensity of a single
		diffraction image.

   Author: Mike Wall
   Date: 3/20/93
   Version: 1.
   Date: 2/6/95
   Version: 2.
      Use orientation matrix to calculate absolute reciprocal lattice vector.

   "genmap <image in> <output file > <spindle_deg> <scale> <hsize> <vsize>
		<header_length>"

   Input is diffraction image, spindle position and scale.  Output is a
   list of voxels (float x, float y, float z, float value) which
   represents a slice of reciprocal space.

   */

#include<mwmask.h>

void main(int argc, char *argv[])







Sep 19 20:37 1995   Page 102


{
  FILE
        *infile,
	*outfile,
	*imagein;

  short
	samples_per_row,
	samples_per_column,
	sample_pitch = DEFAULT_SAMPLE_PITCH;

  char
    error_msg[LINESIZE];

  size_t
    num_values,
    num_wrote,
    num_read;

  long
	i,
	j,
	k;

  DIFFIMAGE
	*imdiff;

  struct voxel
	*map3D;

  float
	scale,
	spindle_deg;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	spindle_deg = DEFAULT_SPINDLE_DEG;
	scale = 1.;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 6:
	  scale = atof(argv[5]);
	  case 5:
	  spindle_deg = atof(argv[4]);
	  case 4:
	  if (strcmp(argv[3], "-") == 0) {
	    outfile = stdout;
	  }
	  else {
	    if ( (outfile = fopen(argv[3],"wb")) == NULL ) {







Sep 19 20:37 1995   Page 103


	      printf("Can't open %s.",argv[3]);
	      exit(0);
	    }
	  }
	  case 3:
	  if (strcmp(argv[2], "-") == 0) {
	    imagein = stdin;
	  }
	  else {
	    if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
	      printf("Can't open %s.",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if ( (infile = fopen(argv[1],"r")) == NULL ) {
	    printf("Can't open %s.",argv[1]);
	    exit(0);
	  }
	  break;
	  default:
	  printf("\n Usage: genmap <input file> "
		 "<image in> <output file> <spindle_deg> "
		 "<scale> \n\n");
	  exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Set main defaults:
 */


	imdiff->spindle_deg = spindle_deg;

  samples_per_row = imdiff->hpixels / sample_pitch;
  samples_per_column = imdiff->vpixels / sample_pitch;
/***/printf("per row, column = %d, %d\n",samples_per_row, samples_per_column);
  map3D = (struct voxel *)malloc(sizeof(struct voxel) * samples_per_row *
					samples_per_column);
  if (!map3D) {
    perror("\nCan't allocate 3D lattice.\n\n");
    exit(0);
  }

/*
 * Read input file which contains the orientation matrix:
 */







Sep 19 20:37 1995   Page 104



  imdiff->infile = infile;
  lgetmat(imdiff);

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

/*
 * Step through the image and generate the corresponsing portion of the 3D map:
 */

  k = 0;
  for (i=0; i<samples_per_column; i++) {
    imdiff->pos.r = i*sample_pitch;
    for (j=0; j<samples_per_row; j++) {
      imdiff->pos.c = j*sample_pitch;
      imdiff->map3D = &map3D[k];
      lgensv(imdiff);
      k++;
    }
  }
  num_values = k;

/*
 * Scale the values to the input line scale:
 */

  for(k=0; k<num_values; k++) {
	map3D[k].value *= scale;
  }

  /*
   * Write the output file:
   */

  num_wrote = fwrite(map3D, sizeof(struct voxel), samples_per_row *
				samples_per_column, outfile);
  if (num_wrote != samples_per_row * samples_per_column){
    printf("Only wrote %ld voxels.", num_wrote);
  }

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);
  free((struct voxel *)map3D);







Sep 19 20:37 1995   Page 105



  /*
   * Close files:
   */

  fclose(infile);
  fclose(imagein);
  fclose(outfile);

}

::::::::::::::
gmparse.c
::::::::::::::
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

#define SPACE 32

void main(void)
{
	char
		inline[255],
		workstr[255],
		*ch;
	
	while (gets(inline) != NULL) {
		strcpy(workstr,inline);
		ch = strchr(workstr,SPACE);
		*ch = 0;
		if (strcmp(workstr,"pcat") != 0) {
			strcpy(workstr, ch + 1);
			ch = strchr(workstr,SPACE);
			*ch = 0;
			strcpy(workstr, ch + 1);
			ch = strchr(workstr, SPACE);
			*ch = 0;
			printf("groff -man -Tascii %s | more -s -f\n",
					workstr);
		}
		else {
			inline[strlen(inline)-1] = 0;
			strcat(inline,"l| ul | more -s -f");
			puts(inline);
		}
	}

}


::::::::::::::
hdrlt.c
::::::::::::::
/* HDRLT.C - Generate a gaussian lattice.








Sep 19 20:37 1995   Page 106


   Author: Mike Wall
   Date: 3/2/95
   Version: 1.

   Usage:
   		"hdrlt <input lattice> <output lattice>"

		Input is lattice.  Output is header of lattice to stdout.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein;

  char
    error_msg[LINESIZE];

  LAT3D
    *lat;

/*
 * Set input line defaults:
 */
	
	latticein = stdin;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: hdrlt <input lattice> \n\n");
	  exit(0);
	}

  /*
   * Initialize lattices:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);







Sep 19 20:37 1995   Page 107


  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  /*
   * Write lattice info to stdout:
   */

  printf("SIZE: %d %d %d\n",lat->xvoxels, lat->yvoxels, lat->zvoxels);
  printf("BOUNDS: (%f,%f) (%f,%f) (%f,%f)\n",
	 lat->xbound.min,lat->xbound.max,
	 lat->ybound.min,lat->ybound.max,
	 lat->zbound.min,lat->zbound.max);
  printf("ORIGIN: (%d,%d,%d)\n",lat->origin.i,lat->origin.j,lat->origin.k);
  printf("VOXEL SCALE: %f %f %f\n",(float)lat->xscale,(float)lat->yscale,
	 (float)lat->zscale);
  printf("VOXEL DIAGONAL: %f\n",sqrtf((double)(lat->xscale*lat->xscale +
					      lat->yscale*lat->yscale +
					      lat->zscale*lat->zscale)));
CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
}


::::::::::::::
headc.c
::::::::::::::
/*
 * HEADC.C	- Output the header of a specified file.  Use number of
		characters given on input line.

   Version: 1.0
   Date: 3/17/94

	Input line is:
			"headc -<number of characters> <input file>"








Sep 19 20:37 1995   Page 108


*/

#include<stdio.h>
#include<stdlib.h>

void main(int argc, char *argv[])
{
	FILE
		*infile;
	
	char
		*header;

	size_t
		header_length,
		num_read,
		num_wrote;

	switch(argc) {
		case 3:
			if (strcmp(argv[2],"-") == 0) {
				infile = stdin;
			}
			else {
			 if ((infile = fopen(argv[2],"rb")) == NULL) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if (argv[1][0] == '-') {
			  if (!(header_length = atol(argv[1]+1))) {
			    printf("Incorrect syntax for header length.\n");
			    exit(0);
			  }
			}
			else {
				printf("Must have '-' in front "
					"of header length.\n");
				exit(0);
			}
			break;
		default:
			printf("\n   Usage: headc -<number of chars> "
				"<input file>\n\n");
	}
	header = (char *)malloc(header_length+1);
	num_read = fread(header, sizeof(char), header_length, infile);
	num_wrote = fwrite(header, sizeof(char), header_length, stdout);

	free((char *)header);
}
::::::::::::::
histim.c
::::::::::::::
/* HISTIM.C - Histogram a specified patch in an image.







Sep 19 20:37 1995   Page 109



   Author: Mike Wall
   Date: 3/12/95
   Version: 1.

   "histim <image in> <x_lower_bound> <x_upper_bound> <y_lower_bound>
		<y_upper_bound> <histogram output file>"

   Input is diffraction image and boundaries of patch.  Output is
   histogram of pixel values in the patch, in ascii format.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*histout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    index = 0;

  DIFFIMAGE
	*imdiff;

  struct rccoords
	upper_bound,
	lower_bound;

  size_t
    *histogram;

  int
    binsize=1;

/*
 * Set input line defaults:
 */
	upper_bound.r = DEFAULT_WINDOW_UPPER;
	upper_bound.c = DEFAULT_WINDOW_UPPER;
	lower_bound.r = DEFAULT_WINDOW_LOWER;
	lower_bound.c = DEFAULT_WINDOW_LOWER;
	imagein = stdin;
	histout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {







Sep 19 20:37 1995   Page 110


	  case 8:
	  binsize = atoi(argv[7]);
		case 7:
			if (strcmp(argv[6], "-") == 0) {
			       histout = stdout;
			}
			else {
			 if ( (histout = fopen(argv[6],"w")) == NULL ) {
				printf("Can't open %s.",argv[6]);
				exit(0);
			 }
			}
		case 6:
			upper_bound.r = (RCCOORDS_DATA)atol(argv[5]);
		case 5:
			lower_bound.r = (RCCOORDS_DATA)atol(argv[4]);
		case 4:
			upper_bound.c = (RCCOORDS_DATA)atol(argv[3]);
		case 3:
			lower_bound.c = (RCCOORDS_DATA)atol(argv[2]);
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: histim <image in> <x_lower_bound> "
			       "<x_upper_bound> <y_lower_bound> "
			       "<y_upper_bound> <histogram file> "
			       "<bin size>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;







Sep 19 20:37 1995   Page 111


  }

/*
 * Allocate memory for histogram:
 */

  histogram = (size_t *)calloc(65536,sizeof(size_t));
  if (!histogram) {
    perror("Couldn't allocate histogram.\n\n");
    exit(0);
  }

/*
 * Set window parameters:
 */

  imdiff->window_upper = upper_bound;
  imdiff->window_lower = lower_bound;

/*
 * Select pixels in the patch and histogram them:
 */

  for(j=0;j<imdiff->vpixels;j++) {
    for(i=0;i<imdiff->hpixels;i++) {
      if ((i >= imdiff->window_lower.c) && (i <= imdiff->window_upper.c)
	  && (j >= imdiff->window_lower.r) && (j <=
					       imdiff->window_upper.r)) {
	histogram[(imdiff->image[index] -
		  imdiff->image[index] % binsize) + 32768]++;
      }
      index++;
    }
  }

/*
 * Write the output file:
 */

  for(i=32768;i<=65535;i=i+binsize) {
      fprintf(histout,"%d %d\n",(int)i-32768,histogram[i]);
  }

CloseShop:

  lfreeim(imdiff);
  free((size_t *)histogram);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(histout);

}







Sep 19 20:37 1995   Page 112




::::::::::::::
histlt.c
::::::::::::::
/* HISTLT.C - Histogram voxel values in a lattice in a specified */
/* spherical shell

   Author: Mike Wall
   Date: 3/22/95
   Version: 1.

   Usage:
   		"histlt <input lattice> <output histogram> <inner
		radius> <outer radius> <binsize>"

		Input is a 3D lattice.  Output is a historgam.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *histout,
    *latticein;

  char
    error_msg[LINESIZE];

  LAT3D
    *lat;

  int
    binsize = 1;

  size_t
    index,
    i,
    j,
    k,
    *histogram,
    r,
    inner_radius,
    outer_radius;

  struct ijkcoords rvec;

  struct xyzcoords rfloat;

  float
    rscale;

  /*
   * Set input line defaults:
   */







Sep 19 20:37 1995   Page 113



  latticein = stdin;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 6:
    binsize = atoi(argv[5]);
    case 5:
    outer_radius = atol(argv[4]);
    case 4:
    inner_radius = atol(argv[3]);
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      histout = stdout;
    }
    else {
      if ( (histout = fopen(argv[2],"w")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein = stdin;
    }
    else {
      if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: histlt <input lattice> <output histogram> "
	   "<inner radius> <outer radius> <binsize>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattices:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");







Sep 19 20:37 1995   Page 114


    exit(0);
  }

/*
 * Allocate memory for histogram:
 */

  histogram = (size_t *)calloc(65536,sizeof(size_t));
  if (!histogram) {
    perror("Couldn't allocate histogram.\n\n");
    exit(0);
  }

/*
 * Generate the histogram:
 */

  lat->inner_radius = inner_radius;
  lat->outer_radius = outer_radius;

  rscale = (lat->xscale*lat->xscale + lat->yscale*lat->yscale +
		 lat->zscale*lat->zscale);
  for(k=0;k<lat->zvoxels;k++) {
    for(j=0;j<lat->yvoxels;j++) {
      for(i=0;i<lat->xvoxels;i++) {
	rvec.i = i - lat->origin.i;
	rvec.j = j - lat->origin.j;
	rvec.k = k - lat->origin.k;
	rfloat.x = lat->xscale * rvec.i;
	rfloat.y = lat->yscale * rvec.j;
	rfloat.z = lat->zscale * rvec.k;
	r = (size_t)sqrtf((rfloat.x*rfloat.x + rfloat.y*rfloat.y +
		       rfloat.z*rfloat.z) / rscale);
	if ((r >= lat->inner_radius) &&
	    (r <= lat->outer_radius) &&
	    ((int)lat->lattice[index] >= -32768) &&
	    ((int)lat->lattice[index] <= 32767)) {
	  histogram[((int)lat->lattice[index] -
		     (int)lat->lattice[index] % binsize) + 32768]++;
	}
	index++;
      }
    }
  }
/*
 * Write the output file:
 */

  for(i=0;i<=65535;i++) {
    if (histogram[i] != (size_t)0) {
      fprintf(histout,"%d %d\n",(int)i-32768,histogram[i]);
    }
  }

CloseShop:








Sep 19 20:37 1995   Page 115


  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(histout);
}

::::::::::::::
intdfim.c
::::::::::::::
/* INTDFIM.C - Integrate diffuse features in a diffraction image and output to
               a file.

   Author: Mike Wall
   Date: 5/28/94
   Version: 1.0

   "intdfim <diffuse features in> <image in> <diffuse features out>"

   Input is ascii diffuse features file and input image.  Output is
   diffuse features file.

*/

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *featurein,
    *featureout,
    *imagein;

  char
    error_msg[LINESIZE];

  long
    i,
    ii;

  DIFFIMAGE
    *imdiff;

  /*
   * Set input line defaults:
   */

  featurein = stdin;
  imagein = stdin;







Sep 19 20:37 1995   Page 116


  featureout = stdout;

  /*
   * Read information from input line:
   */

  switch(argc) {
  case 4:
    if (strcmp(argv[3], "-") == 0) {
      featureout = stdout;
    }
    else {
      if ( (featureout = fopen(argv[3],"wb")) == NULL ) {
	printf("Can't open %s.",argv[3]);
	exit(0);
      }
    }
  case 3:
    if (strcmp(argv[2], "-") == 0) {
      imagein = stdin;
    }
    else {
      if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }
    }
  case 2:
    if ( (featurein = fopen(argv[1],"r")) == NULL ) {
      printf("Can't open %s.",argv[1]);
      exit(0);
    }
    break;
  default:
    printf("\n Usage: intdfim <diffuse features in> "
	   "<image in> <diffuse features out> \n\n");
    exit(0);
  }

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;







Sep 19 20:37 1995   Page 117


  }

  /*
   * Read diffuse features file:
   */

  imdiff->infile = featurein;
  if (lreaddf(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Integrate diffuse features:
   */

  if (lintdfim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Write the output diffuse features file:
   */

  imdiff->outfile = featureout;
  if(lwritedf(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

 CloseShop:

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(featurein);
  fclose(featureout);
}

::::::::::::::
intimdf.c
::::::::::::::
/* INTDFIM.C - Integrate diffuse features in a diffraction image and output to
               a file.

   Author: Mike Wall
   Date: 5/28/94
   Version: 1.0

   "intdfim <diffuse features in> <image in> <diffuse features out>"








Sep 19 20:37 1995   Page 118


   Input is ascii diffuse features file and input image.  Output is
   diffuse features file.

*/

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *featurein,
    *featureout,
    *imagein;

  char
    error_msg[LINESIZE];

  long
    i,
    ii;

  DIFFIMAGE
    *imdiff;

  /*
   * Set input line defaults:
   */

  featurein = stdin;
  imagein = stdin;
  featureout = stdout;

  /*
   * Read information from input line:
   */

  switch(argc) {
  case 4:
    if (strcmp(argv[3], "-") == 0) {
      featureout = stdout;
    }
    else {
      if ( (featureout = fopen(argv[3],"wb")) == NULL ) {
	printf("Can't open %s.",argv[3]);
	exit(0);
      }
    }
  case 3:
    if (strcmp(argv[2], "-") == 0) {
      imagein = stdin;
    }
    else {
      if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }







Sep 19 20:37 1995   Page 119


    }
  case 2:
    if ( (featurein = fopen(argv[1],"r")) == NULL ) {
      printf("Can't open %s.",argv[1]);
      exit(0);
    }
    break;
  default:
    printf("\n Usage: intdfim <diffuse features in> "
	   "<image in> <diffuse features out> \n\n");
    exit(0);
  }

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Read diffuse features file:
   */

  imdiff->infile = featurein;
  if (lreaddf(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto Closeshop;
  }

  /*
   * Integrate diffuse features:
   */

  if (lintdfim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto Closeshop;
  }

  /*
   * Write the output diffuse features file:
   */

  imdiff->outfile = featureout;







Sep 19 20:37 1995   Page 120


  if(lwritedf(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

 CloseShop:

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(featurein);
  fclose(featureout);
}

::::::::::::::
map2lat.c
::::::::::::::
/* MAP2LAT.C - Generate a 3D lattice from an input voxel map.

   Author: Mike Wall
   Date: 3/28/93
   Version: 1.

   Usage:
   "map2lat <input file> <output file> <inner radius>
   <outer radius> <x-origin> <y-origin> <z-origin> <minrange>"

   Input is a list of voxels (float x, float y,
   float z, float value).  Output
   is a 3D lattice representation of the voxel map.

*/

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *infile,
    *outfile;

  char
    error_msg[LINESIZE];

  struct voxel
    *voxel_data;

  size_t
    index,
    i,
    j,
    k,







Sep 19 20:37 1995   Page 121


    num_read,
    num_wrote;

  LAT3D
    *lat;

  size_t
    *ct;

  int
    hh,
    kk,
    ll;

  float
    minrange,
    q_squared,
    inner_radius,
    inner_radius_sq,
    outer_radius,
    outer_radius_sq;

  struct xyzcoords
    dist,
    pos;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  infile = stdin;
  outfile = stdout;
  inner_radius= DEFAULT_INNER_RADIUS_LT;
  outer_radius = DEFAULT_OUTER_RADIUS_LT;
  inner_radius_sq = inner_radius*inner_radius;
  outer_radius_sq = DEFAULT_BOUND_MAX*DEFAULT_BOUND_MAX;
  minrange = DEFAULT_MINRANGE;
  origin.i = origin.j = origin.k = DEFAULT_LATTICE_ORIGIN;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 9:
    minrange = atof(argv[8]);
    case 8:
    origin.k = atol(argv[7]);
    case 7:
    origin.j = atol(argv[6]);
    case 6:
    origin.i = atol(argv[5]);
    case 5:
    outer_radius = atof(argv[4]);







Sep 19 20:37 1995   Page 122


    outer_radius_sq = outer_radius*outer_radius;
    case 4:
    inner_radius = atof(argv[3]);
    inner_radius_sq = inner_radius*inner_radius;
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      outfile = stdout;
    }
    else {
      if ((outfile = fopen(argv[2],"wb")) == NULL) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      infile = stdin;
    }
    else {
      if ( (infile = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: map2lat <input file> "
	   "<output file> <inner radius> <outer radius> "
	   "<x-origin> <y-origin> <z-origin> <minrange>\n\n");
    exit(0);
  }

  /*
   * Allocate memory:
   */

  voxel_data = (struct voxel *)malloc(sizeof(struct voxel));
  if (!voxel_data) {
    printf("\n***Unable to allocate all memory.\n");
    goto CloseShop;
  }

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.n\n");
    exit(0);
  }

  /*
   * Set main defaults:
   */

  lat->map3D = voxel_data;







Sep 19 20:37 1995   Page 123


  lat->minrange.x = lat->minrange.y = lat->minrange.z = minrange;
  lat->origin = origin;
  lat->xbound.min = - lat->origin.i*lat->xscale;
  lat->xbound.max = (lat->xvoxels - lat->origin.i - 1)*lat->xscale;
  lat->ybound.min = - lat->origin.j*lat->yscale;
  lat->ybound.max = (lat->yvoxels - lat->origin.j - 1)*lat->yscale;
  lat->zbound.min = - lat->origin.k*lat->zscale;
  lat->zbound.max = (lat->zvoxels - lat->origin.k - 1)*lat->zscale;

  /*
   * Allocate ct:
   */

  ct = (size_t *)calloc(lat->lattice_length,sizeof(size_t));
  if (!ct) {
    printf("\nNot enough room to allocate counting table (ct).\n\n");
    exit(0);
  }

  /*
   * Step through input file and update current bounds:
   */

  while ((num_read = fread(voxel_data, sizeof(struct voxel), 1, infile)) == 1){
    q_squared = (voxel_data->pos.x*voxel_data->pos.x +
		 voxel_data->pos.y*voxel_data->pos.y +
		 voxel_data->pos.z*voxel_data->pos.z);
    if ((inner_radius_sq < q_squared) && (outer_radius_sq >
					  q_squared)) {
	if (voxel_data->pos.x < 0) {
	  hh = (int)(voxel_data->pos.x - .5);
	} else {
	  hh = (int)(voxel_data->pos.x + .5);
	}
	if (voxel_data->pos.y < 0) {
	  kk = (int)(voxel_data->pos.y - .5);
	} else {
	  kk = (int)(voxel_data->pos.y + .5);
	}
	if (voxel_data->pos.z < 0) {
	  ll = (int)(voxel_data->pos.z - .5);
	} else {
	  ll = (int)(voxel_data->pos.z + .5);
	}
	i = (size_t) (voxel_data->pos.x + lat->origin.i + .5);
	j = (size_t) (voxel_data->pos.y + lat->origin.j + .5);
	k = (size_t) (voxel_data->pos.z + lat->origin.k + .5);
      dist.x = (float)fabsf(voxel_data->pos.x - (float)hh);
      dist.y = (float)fabsf(voxel_data->pos.y - (float)kk);
      dist.z = (float)fabsf(voxel_data->pos.z - (float)ll);
      if ((voxel_data->value != lat->mask_tag) &&
	  (voxel_data->value != 0) &&
	  (dist.x > lat->minrange.x) &&
	  (dist.y > lat->minrange.y) &&
	  (dist.z > lat->minrange.z)) {
	index = k*lat->xyvoxels + j*lat->xvoxels + i;







Sep 19 20:37 1995   Page 124


	if (index >= lat->lattice_length) {
	  printf("\nTried to index lattice outside of range.\n");
	  goto CloseShop;
	}
	if (ct[index == 0]) {
	  lat->lattice[index] = (LATTICE_DATA_TYPE)voxel_data->value;
	  ct[index]++;
	} else {
	  lat->lattice[index] =
	    (LATTICE_DATA_TYPE)(((float)ct[index]*lat->lattice[index] +
				 voxel_data->value)
				/(float)(ct[index]+1.));
/*printf("%d %d %d : %f %f %f : %f\n",i,j,k,voxel_data->pos.x,voxel_data->pos.y,voxel_data->pos.z,voxel_data->value);/***/
	  ct[index]++;
	}
      }
    }
  }

  /*
   * Write lattice to output file:
   */

  lat->outfile = outfile;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);
  free((struct voxel *)voxel_data);
  free((size_t *)ct);

  /*
   * Close files:
   */

  fclose(infile);
}


















Sep 19 20:37 1995   Page 125
























::::::::::::::
mapbound.c
::::::::::::::
/* MAPBOUND.C - Output the bounds in x,y,z,I for a list of input voxels (map).

   Author: Mike Wall
   Date: 3/20/93
   Version: 1.

   Usage:
   		"mapbound <input file>"

   Input is a list of voxels (float x, float y, float z, float value).  Output
	is (min(x),max(x),min(y),max(y),min(z),max(z),min(value),max(value).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile;

  char
    error_msg[LINESIZE];

  struct voxel
	*voxel_data;

  size_t
	num_read;

  LAT3D







Sep 19 20:37 1995   Page 126


	*lat;

/*
 * Set input line defaults:
 */
	
	infile = stdin;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				infile = stdin;
			}
			else {
			 if ( (infile = fopen(argv[1],"r")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
		case 1:
			break;
		default:
			printf("\n Usage: genmap <input file> \n\n");
			exit(0);
	}

/*
 * Allocate memory:
 */

  voxel_data = (struct voxel *)malloc(sizeof(struct voxel));
  lat = (LAT3D *)malloc(sizeof(LAT3D));
  if (!lat) {
    printf("\n***Unable to allocate all memory.\n");
    goto CloseShop;
  }

/*
 * Set main defaults:
 */

	lat->map3D = voxel_data;
	lat->mask_tag = PUNCH_TAG;

/*
 * Step through input file and update current bounds:
 */

  while ((num_read= fread(voxel_data, sizeof(struct voxel), 1, infile)) == 1) {
	lupdbd(lat);
  }

/*







Sep 19 20:37 1995   Page 127


 * Print bounds to standard output:
 */

  printf("xb(min,max) = %g %g\n"
	 "yb(min,max) = %g %g\n"
	 "zb(min,max) = %g %g\n"
	 "valuebound(min,max) = %g %g\n\n", lat->xbound.min, lat->xbound.max,
				lat->ybound.min, lat->ybound.max,
				lat->zbound.min, lat->zbound.max,
				lat->valuebound.min, lat->valuebound.max);

CloseShop:

  /*
   * Free allocated memory:
   */

  free((LAT3D *)lat);
  free((struct voxel *)voxel_data);

  /*
   * Close files:
   */

  fclose(infile);
}

::::::::::::::
maskimg.c
::::::::::::::
/* MASKIMG.C - Create a pixel mask based on input file coordinates.

   Author: Mike Wall   Modified by:Fredrik Osterberg
   Date: 1/11/93
   Version: 1.

   "maskimg <input file> <image in> <image out> <hsize> <vsize>"

   Input is ascii coordinates file.  Output is 16-bit
   image of specified size (1024 x 1024 default).

   Date: 3/15/94
   Version: 2.
		Port to SGI.  Try to modularize the procedures.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile,
	*imagein,
	*imageout;

  char







Sep 19 20:37 1995   Page 128


    error_msg[LINESIZE];

  size_t
    num_wrote,
    num_read;

  long
	i,
	ii;

  DIFFIMAGE
	*imdiff;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ( (infile = fopen(argv[1],"r")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: maskimg <input file> "
				"<image in> <image out> \n\n");
			exit(0);
	}








Sep 19 20:37 1995   Page 129


/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }


  /*
   * Generate mask:
   */

	lgetanls(imdiff);
	if (imdiff->mask_count == 0) {
		printf("\nNo points in mask generated.\n");
		goto CloseShop;
	}

/*
 * Read in peaks from input file:
 */
	imdiff->infile = infile;
	lgetpks(imdiff);
/*
 * Generate overload list:
 */

	lgetovld(imdiff);

  /*
   *  Step through the peak table and punch out holes in the image.
   */
printf("\nNumber of peaks: %ld\n\n",(long)imdiff->peak_count);
	for(i=0;i<imdiff->peak_count;i++) {
		imdiff->pos.c = (short)imdiff->peak[i].y;
		imdiff->pos.r = (short)imdiff->peak[i].x;
		lpunch(imdiff);
	}
	for(i=0;i<imdiff->overload_count;i++) {
		imdiff->pos = imdiff->overload[i];
		lpunch(imdiff);
	}

/*







Sep 19 20:37 1995   Page 130


 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

CloseShop:

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(infile);
  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
medim.c
::::::::::::::
/* MEDIM.C - Calculate the median of an image in a specified size box.

   Author: Mike Wall
   Date: 4/8/95
   Version: 1.

   "medim <image in> <image out> <mask size>"

   Input is ascii coordinates file.  Output is 16-bit
   image of specified size (1024 x 1024 default).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  DIFFIMAGE
	*imdiff;

  int
    binsize,
    mask_size;
/*
 * Set input line defaults:
 */







Sep 19 20:37 1995   Page 131



  binsize = DEFAULT_MODE_BIN_SIZE;
  mask_size = DEFAULT_MODE_MASK_SIZE;
  imagein = stdin;
  imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 5:
	  binsize = atoi(argv[4]);
	  case 4:
	  mask_size = atoi(argv[3]);
	  case 3:
	  if (strcmp(argv[2], "-") == 0) {
	    imageout = stdout;
	  }
	  else {
	    if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	      printf("Can't open %s.",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1], "-") == 0) {
	    imagein = stdin;
	  }
	  else {
	    if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	      printf("Can't open %s.",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: modeim "
		 "<image in> <image out> <mask size> <bin size>\n\n");
	  exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {







Sep 19 20:37 1995   Page 132


    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Initialize mask parameters:
   */

  imdiff->mode_height = mask_size - 1;
  imdiff->mode_width = mask_size - 1;
  imdiff->mode_binsize = binsize;

/*
 * Mode image:
 */

  lmedim(imdiff);

/*
 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

CloseShop:

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}





::::::::::::::
minr.c
::::::::::::::
/* MINR.C - Generate a table of minimum voxel values as a function of radius
		for an input 3D lattice.

   Author: Mike Wall
   Date: 3/28/93
   Version: 1.

   Usage:







Sep 19 20:37 1995   Page 133


   		"minr <input file> <output file>"

   Input is a 3D lattice.  Output is a list of minima by radius, to be labelled
	(0,1,2,3,...).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile,
	*outfile;

  char
    error_msg[LINESIZE];

  size_t
	i,
	j,
	k,
	xyvoxels,
	num_read,
	num_wrote;

  LAT3D
	*lat;

  RFILE_DATA_TYPE *rfile;

  float
	xscale,
	yscale,
	zscale;

/*
 * Set input line defaults:
 */
	
	infile = stdin;
	outfile = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 3:
			if (strcmp(argv[2],"-") == 0) {
				outfile = stdout;
			}
			else {
			 if ((outfile = fopen(argv[2],"wb")) == NULL) {
				printf("\nCan't open %s.\n\n",argv[2]);
				exit(0);
			 }







Sep 19 20:37 1995   Page 134


			}
		case 2:
			if (strcmp(argv[1],"-") == 0) {
				infile = stdin;
			}
			else {
			 if ( (infile = fopen(argv[1],"rb")) == NULL ) {
				printf("\nCan't open %s.\n\n",argv[1]);
				exit(0);
			 }
			}
		case 1:
			break;
		default:
			printf("\n Usage: minr <input file> "
				"<output file>\n\n");
			exit(0);
	}

/*
 * Allocate memory for lattice:
 */

  lat = (LAT3D *)malloc(sizeof(LAT3D));
  if (!lat) {
    printf("\n***Unable to allocate all memory.\n");
    goto CloseShop;
  }

/*
 * Set main defaults:
 */

	lat->infile = infile;
	lat->outfile = outfile;
	lat->mask_tag = DEFAULT_LATTICE_MASK_TAG;

/*
 * Read in 3D lattice descriptor:
 */

  num_read = fread(&lat->xvoxels, sizeof(long), 1, infile);
  num_read = fread(&lat->yvoxels, sizeof(long), 1, infile);
  num_read = fread(&lat->zvoxels, sizeof(long), 1, infile);
  num_read = fread(&lat->xbound, sizeof(struct bounds), 1, infile);
  num_read = fread(&lat->ybound, sizeof(struct bounds), 1, infile);
  num_read = fread(&lat->zbound, sizeof(struct bounds), 1, infile);
  xyvoxels = lat->xvoxels * lat->yvoxels;
  lat->lattice_length = xyvoxels * lat->zvoxels;
  lat->rfile_length = 0;

/*
 * Allocate memory for 3D lattice:
 */

  lat->lattice = (LATTICE_DATA_TYPE *)calloc(lat->lattice_length,







Sep 19 20:37 1995   Page 135


				sizeof(LATTICE_DATA_TYPE));
  if (!lat->lattice) {
	printf("\nNot enough room to allocate 3D lattice.\n\n");
	exit(0);
  }

/*
 * Read in lattice:
 */

  num_read = fread(lat->lattice, sizeof(LATTICE_DATA_TYPE), lat->lattice_length,
						infile);
  if (num_read != lat->lattice_length) {
    printf("/nCouldn't read all of the lattice from input file.\n\n");
    exit(0);
  }

/*
 * Allocate memory for rfile:
 */

  lat->rfile = (LATTICE_DATA_TYPE *)calloc(MAX_RFILE_LENGTH,
					sizeof(LATTICE_DATA_TYPE));
  if (!lat->lattice) {
  	printf("\nNot enough room to allocate 3D lattice.\n\n");
  	exit(0);
  }

/*
 * Generate minimum rfile:
 */

  lminr(lat);

/*
 * Write rfile to output file:
 */

  num_wrote = fwrite(lat->rfile, sizeof(RFILE_DATA_TYPE), lat->rfile_length,
				outfile);
CloseShop:

  /*
   * Free allocated memory:
   */

  free((LATTICE_DATA_TYPE *)lat->lattice);
  free((LATTICE_DATA_TYPE *)lat->rfile);
  free((LAT3D *)lat);

  /*
   * Close files:
   */

  fclose(infile);
  fclose(outfile);







Sep 19 20:37 1995   Page 136


}

::::::::::::::
minrim.c
::::::::::::::
/* MINRIM.C - Calculate the minimum intensity as a function of radius for an
		input image.

   Author: Mike Wall
   Date: 4/4/93
   Version: 1.

   "minrim <input image> <output rfile> <x origin> <y origin>"

   Input is TIFF TV6 image.  Output is a list of values of I(r).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*outfile;

  char
    error_msg[LINESIZE];

  size_t
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff;

  struct rccoords origin;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	outfile = stdout;
	origin.r = DEFAULT_IMAGE_ORIGIN;
	origin.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 5:
			origin.r = (RCCOORDS_DATA)atoi(argv[4]);
		case 4:
			origin.c = (RCCOORDS_DATA)atoi(argv[3]);
		case 3:







Sep 19 20:37 1995   Page 137


			if ( (outfile = fopen(argv[2],"wb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			}
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: minrim <input image> "
				"<output rfile> \n\n");
			exit(0);
	}

 /*
  * Initialize diffraction image:
  */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Set main defaults:
 */

	imdiff->origin = origin;


/*
 * Read diffraction image:
 */
	imdiff->infile = imagein;
	if (lreadim(imdiff) != 0) {
		perror(imdiff->error_msg);
		goto CloseShop;
	}


  /*
   * Generate rfile:
   */

	lminrim(imdiff);

  /*
   * Write the output rfile:
   */







Sep 19 20:37 1995   Page 138



   imdiff->outfile = outfile;
   if(lwriterf(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

  num_wrote = fwrite(imdiff->rfile, sizeof(RFILE_DATA_TYPE),
		imdiff->rfile_length, outfile);
  if (num_wrote != imdiff->rfile_length){
    printf("Only wrote %ld words to rfile.", num_wrote);
  }

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(outfile);

}

::::::::::::::
modeim.c
::::::::::::::
/* MODEIM.C - Calculate the mode of an image in a specified size box.

   Author: Mike Wall
   Date: 2/2/95
   Version: 1.

   "modeim <image in> <image out> <mask size> <bin size>"

   Input is ascii coordinates file.  Output is 16-bit
   image of specified size (1024 x 1024 default).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  DIFFIMAGE
	*imdiff;







Sep 19 20:37 1995   Page 139



  int
    mask_size,
    binsize;
/*
 * Set input line defaults:
 */
	
  mask_size = DEFAULT_MODE_MASK_SIZE;
  binsize = DEFAULT_MODE_BIN_SIZE;
  imagein = stdin;
  imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 5:
	  binsize = atoi(argv[4]);
	  case 4:
	  mask_size = atoi(argv[3]);
	  case 3:
	  if (strcmp(argv[2], "-") == 0) {
	    imageout = stdout;
	  }
	  else {
	    if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	      printf("Can't open %s.",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1], "-") == 0) {
	    imagein = stdin;
	  }
	  else {
	    if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	      printf("Can't open %s.",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: modeim "
		 "<image in> <image out> <mask size> <bin size>\n\n");
	  exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }







Sep 19 20:37 1995   Page 140



/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Initialize mask parameters:
   */

  imdiff->mode_height = mask_size - 1;
  imdiff->mode_width = mask_size - 1;
  imdiff->mode_binsize = binsize;

/*
 * Mode image:
 */

  lmodeim(imdiff);

/*
 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

CloseShop:

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
mulim.c
::::::::::::::
/* MULIM.C - Multiply two images pixel-by-pixel.

   Author: Mike Wall
   Date: 4/27/94
   Version: 1.







Sep 19 20:37 1995   Page 141



   "mulim <input image 1> <x origin 1> <y origin 1> <input image 2> <x origin 2> <y origin 2> <output image>"

   Input two diffraction images in TIFF TV6 format.  Output is the second
   subtracted from the first, taking origin translation into account.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein1,
	*imagein2,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

  struct rccoords
	origin1,
	origin2;

  int
	got_r2 = 0,
	got_c2 = 0;
/*
 * Set input line defaults:
 */
	
	imagein1 = stdin;
	imagein2 = stdin;
	imageout = stdout;
	origin1.r = DEFAULT_IMAGE_ORIGIN;
	origin1.c = DEFAULT_IMAGE_ORIGIN;
	origin2.r = DEFAULT_IMAGE_ORIGIN;
	origin2.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 8:
			if (strcmp(argv[7], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[7],"wb")) == NULL ) {
				printf("Can't open %s.",argv[7]);
				exit(0);
			 }







Sep 19 20:37 1995   Page 142


			}
		case 7:
			origin2.r = (RCCOORDS_DATA)atoi(argv[6]);
			got_r2 = 1;
		case 6:
			origin2.c = (RCCOORDS_DATA)atoi(argv[5]);
			got_c2 = 1;
		case 5:
			if (strcmp(argv[4], "-") == 0) {
				imagein2 = stdin;
			}
			else {
			 if ( (imagein2 = fopen(argv[4],"rb")) == NULL ) {
				printf("Can't open %s.",argv[4]);
				exit(0);
			 }
			}
		case 4:
			origin1.r = (RCCOORDS_DATA)atoi(argv[3]);
			if (got_r2 == 0) origin2.r = origin1.r;
		case 3:
			origin1.c = (RCCOORDS_DATA)atoi(argv[2]);
			if (got_c2 == 0) origin2.c = origin1.c;
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein1 = stdin;
			}
			else {
			 if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: mulim <input image 1> "
				"<x origin 1> <y origin 1> <input image 2> "
				"<x origin 2> <y origin 2> "
				"<output image>\n\n");
			exit(0);
	}
/*
 * Initialize diffraction images:
 */

  if (((imdiff1 = linitim()) == NULL) || ((imdiff2 = linitim()) == NULL)) {
    perror("Couldn't initialize diffraction images.\n\n");
    exit(0);
  }

/*
 * Set main defaults:
 */

	imdiff1->origin = origin1;
	imdiff2->origin = origin2;







Sep 19 20:37 1995   Page 143




 /*
  * Read diffraction image:
  */

  imdiff1->infile = imagein1;
  if (lreadim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

  imdiff2->infile = imagein2;
  if (lreadim(imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

  if (lmulim(imdiff1,imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }


/*
 * Write the output image:
 */

  imdiff1->outfile = imageout;
  if(lwriteim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(imagein1);
  fclose(imagein2);
  fclose(imageout);
}

::::::::::::::
mullt.c
::::::::::::::
/* MULLT.C - Calculate the voxel-by-voxel product of two lattices.







Sep 19 20:37 1995   Page 144



   Author: Mike Wall
   Date: 4/11/95
   Version: 1.

   Usage:
   		"mullt <input lattice 1> <input lattice 2> <output
		lattice>"

		Input is two 3D lattices.  Output is a lattice which
		is the product of the two.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_wrote;

  LAT3D
    *lat1,
    *lat2;

  RFILE_DATA_TYPE *rfile;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  latticein1 = stdin;
  latticein2 = stdin;
  latticeout = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 4:
    if ((latticeout = fopen(argv[3],"wb")) == NULL) {
      printf("\nCan't open %s.\n\n",argv[3]);
      exit(0);







Sep 19 20:37 1995   Page 145


    }
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      latticein2 = stdin;
    }
    else {
      if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein1 = stdin;
    }
    else {
      if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: mullt <input lattice 1> <input lattice 2> "
	   "<output lattice>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if (((lat1 = linitlt()) == NULL) || ((lat2 = linitlt()) == NULL)) {
    perror("Couldn't initialize lattices.\n\n");
    exit(0);
  }

  /*
   * Read in lattices:
   */

  lat1->infile = latticein1;
  if (lreadlt(lat1) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  lat2->infile = latticein2;
  if (lreadlt(lat2) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the product lattice:
 */







Sep 19 20:37 1995   Page 146



  lmullt(lat1,lat2);

  /*
   * Write lattice to output file:
   */

  lat1->outfile = latticeout;
  if (lwritelt(lat1) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat1);
  lfreelt(lat2);

  /*
   * Close files:
   */

  fclose(latticeout);
  fclose(latticein1);
  fclose(latticein2);
}

::::::::::::::
mulrf.c
::::::::::::::
/* MULRF.C - Multiply two rfiles.

   Author: Mike Wall
   Date: 1/12/95
   Version: 1.

   "mulrf <input rfile 1> <input rfile 2> <output rfile>"

   Input is two rfiles.  Output is product of rfiles, point-by-point.
   second.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile1,
	*infile2,
	*outfile;








Sep 19 20:37 1995   Page 147


  size_t
    i;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

/*
 * Set input line defaults:
 */
	
	infile1 = stdin;
	infile2 = stdin;
	outfile = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				outfile = stdout;
			}
			else {
			 if ( (outfile = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				infile2 = stdin;
			}
			else {
			 if ( (infile2 = fopen(argv[2],"rb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ( (infile1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: mulrf <input rfile 1> "
				"<input rfile 2> <output rfile>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction images:
 */

  if ((imdiff1 = linitim()) == NULL) {







Sep 19 20:37 1995   Page 148


    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

  if ((imdiff2 = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

 /*
  * Read in rfiles:
  */

   imdiff1->infile = infile1;
   if (lreadrf(imdiff1) != 0) {
     perror(imdiff1->error_msg);
     goto CloseShop;
   }

   imdiff2->infile = infile2;
   if (lreadrf(imdiff2) != 0) {
     perror(imdiff2->error_msg);
     goto CloseShop;
   }

/*
 * Multiply rfiles:
 */

   lmulrf(imdiff1,imdiff2);

/*
 * Write the output rfile:
 */

   imdiff1->outfile = outfile;
   if(lwriterf(imdiff1) != 0) {
     perror(imdiff1->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(infile1);
  fclose(infile2);







Sep 19 20:37 1995   Page 149


  fclose(outfile);

}
::::::::::::::
mulrfim.c
::::::::::::::
/* LMULRFIM - Subtract I(r) from a diffraction image.

   Author: Mike Wall
   Date: 4/4/94
   Version: 1.

   "mulrfim <input rfile> <image in> <image out> <x origin> <y origin>"

   Input is rfile and image.  Output is 16-bit
   image multiplied by rfile.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile,
	*imagein,
	*imageout;

  size_t
    i,
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff;

  struct rccoords
	origin;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;
	origin.r = DEFAULT_IMAGE_ORIGIN;
	origin.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 6:
			origin.r = (RCCOORDS_DATA)atoi(argv[5]);
		case 5:
			origin.c = (RCCOORDS_DATA)atoi(argv[4]);







Sep 19 20:37 1995   Page 150


		case 4:
			if (strcmp(argv[3], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ( (infile = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: mulrfim <input file> "
				"<image in> <image out> <x origin> "
				"<y origin>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Set defaults:
 */

  imdiff->origin = origin;

 /*
  * Read diffraction image:
  */

   imdiff->infile = imagein;
   if (lreadim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;







Sep 19 20:37 1995   Page 151


   }

 /*
  * Read in rfile:
  */

   imdiff->infile = infile;
   if (lreadrf(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

/*
 * Multiply image by rfile:
 */

   lmulrfim(imdiff);

/*
 * Write the output image:
 */

   imdiff->outfile = imageout;
   if(lwriteim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */

  free((RFILE_DATA_TYPE *)imdiff->rfile);
  free((IMAGE_DATA_TYPE *)imdiff->image);
  free((char *)imdiff->header);
  free((DIFFIMAGE *)imdiff);

/*
 * Close files:
 */

  fclose(infile);
  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
mulsclt.c
::::::::::::::
/* MULSCLT.C - Multiply each voxel in a lattice by a scalar.

   Author: Mike Wall
   Date: 3/21/95







Sep 19 20:37 1995   Page 152


   Version: 1.

   Usage:
   		"mulsclt <input lattice> <scalar> <output lattice>"

		Input is a scalar and an input
			lattice.  Output is a lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_read,
    num_wrote;

  LAT3D
    *lat;

  RFILE_DATA_TYPE
    *rfile;

  float
    scale_factor;

/*
 * Set input line defaults:
 */
	scale_factor = 1.;
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 4:
	  scale_factor = atof(argv[3]);
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    latticeout = stdout;
	  }
	  else {
	    if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[1]);







Sep 19 20:37 1995   Page 153


	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: mulsclt <input lattice> <output lattice> "
		 "<scale factor>\n\n");
	  exit(0);
	}

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the scaled lattice:
 */

  lat->rfile[0] = scale_factor;
  lmulsclt(lat);

/*
 * Write lattice to output file:
 */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }








Sep 19 20:37 1995   Page 154


CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(latticeout);
}

::::::::::::::
nign.c
::::::::::::::
/* NIGN.C - Calculate the number of ignored pixels vs radius for an
		input image.

   Author: Mike Wall
   Date: 5/5/93
   Version: 1.

   "nign <input image> <output rfile> <x origin> <y origin>"

   Input is TIFF TV6 image.  Output is a list of values of N(r).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*outfile;

  char
    error_msg[LINESIZE];

  size_t
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff;

  struct rccoords origin;

/*
 * Set input line defaults:
 */
	







Sep 19 20:37 1995   Page 155


	imagein = stdin;
	outfile = stdout;
	origin.r = DEFAULT_IMAGE_ORIGIN;
	origin.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 5:
			origin.r = (RCCOORDS_DATA)atoi(argv[4]);
		case 4:
			origin.c = (RCCOORDS_DATA)atoi(argv[3]);
		case 3:
			if ( (outfile = fopen(argv[2],"wb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			}
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: avgrim <input image> "
				"<output rfile> <x origin> <y origin>\n\n");
			exit(0);
	}


/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Set defaults:
 */

  imdiff->origin = origin;

/*
 * Read diffraction image:
 */
	imdiff->infile = imagein;
	if (lreadim(imdiff) != 0) {







Sep 19 20:37 1995   Page 156


		perror(imdiff->error_msg);
		goto CloseShop;
	}


  /*
   * Generate rfile:
   */

	lnign(imdiff);

/*
 * Write the output rfile:
 */

   imdiff->outfile = outfile;
   if(lwriterf(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(outfile);

}

::::::::::::::
noiseim.c
::::::::::::::
/* NOISEIM - Create a noisy image.

   Author: Mike Wall
   Date: 4/10/95
   Version: 1.

   "noiseim <image in> <image out> <amplitude>"

   Input is image and amplitude.
   Output is noisy image of type input image.

   */

#include<mwmask.h>








Sep 19 20:37 1995   Page 157


void main(int argc, char *argv[])
{
  FILE
    *imagein,
    *imageout;

  size_t
    i;

  DIFFIMAGE
    *imdiff;

  IMAGE_DATA_TYPE
    image_value;

  float
    amplitude,
    pitch;

  /*
   * Set input line defaults:
   */

  imagein = stdin;
  imageout = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 4:
    amplitude = atof(argv[3]);
    case 3:
    if (strcmp(argv[2], "-") == 0) {
      imageout = stdout;
    }
    else {
      if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1], "-") == 0) {
      imagein = stdin;
    }
    else {
      if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	printf("Can't open %s.",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: noiseim <image in> <image out> <amplitude> "
	   "\n\n");







Sep 19 20:37 1995   Page 158


    exit(0);
  }

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }


  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Set input line specs:
   */

  imdiff->amplitude = amplitude;

  /*
   * Create noisy image:
   */

  lnoiseim(imdiff);

  /*
   * Write the output image:
   */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);

  /*
   * Close files:
   */







Sep 19 20:37 1995   Page 159



  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
normim.c
::::::::::::::
/* NORMIM.C - Normalize the intensity in an image st pixels are */
/* proportional to I(q).  Includes a correction for detector face rotation.

   Author: Mike Wall
   Date: 2/24/95
   Version: 1.

   "normim <image in> <image out> <x origin> <y origin>
      <distance[mm]> <cassette rotx> <cassette roty>"

   Input is diffraction image.  Output is normalized corrected image.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff;

  struct rccoords
	origin;

  float
    distance_mm;

  struct xyzcoords
    cassette;

/*
 * Set input line defaults:
 */

  origin.r = DEFAULT_IMAGE_ORIGIN;
  origin.c = DEFAULT_IMAGE_ORIGIN;
  distance_mm = DEFAULT_DISTANCE_MM;
  cassette.x = DEFAULT_CASSETTE_ROTX;
  cassette.y = DEFAULT_CASSETTE_ROTY;
  imagein = stdin;







Sep 19 20:37 1995   Page 160


  imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 8:
	  cassette.y = (XYZCOORDS_DATA)atof(argv[7]);
	  case 7:
	  cassette.x = (XYZCOORDS_DATA)atof(argv[6]);
	  case 6:
	  distance_mm = atof(argv[5]);
	  case 5:
	  origin.r = (RCCOORDS_DATA)atol(argv[4]);
	  case 4:
	  origin.c = (RCCOORDS_DATA)atol(argv[3]);
	  case 3:
	  if (strcmp(argv[2], "-") == 0) {
	    imageout = stdout;
	  }
	  else {
	    if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	      printf("Can't open %s.",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1], "-") == 0) {
	    imagein = stdin;
	  }
	  else {
	    if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	      printf("Can't open %s.",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: normim <image in> <image out> "
		 "<x origin> <y origin> <distance [mm]>\n\n");
	  exit(0);
	}

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

  /*
   * Set the origin for the image:
   */








Sep 19 20:37 1995   Page 161


  imdiff->origin = origin;

  /*
   * Set sample-to-detector distance for the image
   */

  imdiff->distance_mm = distance_mm;

  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Normalize the diffraction image:
   */

  imdiff->cassette.x = cassette.x;
  imdiff->cassette.y = cassette.y;
  lnormim(imdiff);

  /*
   * Write the output image:
   */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(imageout);

}


::::::::::::::
ovldim.c







Sep 19 20:37 1995   Page 162


::::::::::::::
/* OVLDIM.C - Punch out overloads in an image.

   Author: Mike Wall   Modified by:Fredrik Osterberg
   Date: 3/14/95
   Version: 1.

   "ovldim <image in> <image out>"

   Input is image with overloads.  Output is image with overloads
   expanded.

*/

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  char
    error_msg[LINESIZE];

  DIFFIMAGE
	*imdiff;

  size_t
    i;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */
  switch(argc) {
    case 3:
    if (strcmp(argv[2], "-") == 0) {
      imageout = stdout;
    }
    else {
      if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1], "-") == 0) {
      imagein = stdin;
    }







Sep 19 20:37 1995   Page 163


    else {
      if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	printf("Can't open %s.",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: ovldim "
	   "<image in> <image out> \n\n");
    exit(0);
  }

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }


  /*
   * Generate mask:
   */

  imdiff->mask_inner_radius = 0;
  imdiff->mask_outer_radius = DEFAULT_OVERLOAD_RADIUS;

  lgetanls(imdiff);
  if (imdiff->mask_count == 0) {
    printf("\nNo points in mask generated.\n");
    goto CloseShop;
  }

  /*
   * Generate overload list:
   */

  lgetovld(imdiff);

  printf("Overload count: %d\n",imdiff->overload_count);

  /*
   *  Step through the peak table and punch out holes in the image.







Sep 19 20:37 1995   Page 164


   */
  for(i=0;i<imdiff->overload_count;i++) {
    imdiff->pos = imdiff->overload[i];
    lpunch(imdiff);
  }

/*
 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

CloseShop:

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
peakim.c
::::::::::::::
/* PEAKIM - Create an image with various size and strength peaks.

   Author: Mike Wall
   Date: 4/6/95
   Version: 1.

   "waveim <image in> <image out> <max_amplitude> <pitch>"

   Input is image, amplitude and pitch.
   Output is image with peaks of varying amplitude and width
   of type input image.  Amplitude varies from zero to max_amplitude
   in x, while width varies from 1 pixel to pitch in x.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *imagein,
    *imageout;

  size_t







Sep 19 20:37 1995   Page 165


    i;

  DIFFIMAGE
    *imdiff;

  IMAGE_DATA_TYPE
    image_value;

  float
    amplitude,
    pitch;

  /*
   * Set input line defaults:
   */

  imagein = stdin;
  imageout = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 5:
    pitch = atof(argv[4]);
    case 4:
    amplitude = atof(argv[3]);
    case 3:
    if (strcmp(argv[2], "-") == 0) {
      imageout = stdout;
    }
    else {
      if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1], "-") == 0) {
      imagein = stdin;
    }
    else {
      if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	printf("Can't open %s.",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: peakim <image in> <image out> <max_amplitude> "
	   "<pitch>\n\n");
    exit(0);
  }

  /*
   * Initialize diffraction image:







Sep 19 20:37 1995   Page 166


   */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }


  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Set input line specs:
   */

  imdiff->amplitude = amplitude;
  imdiff->pitch = pitch;

  /*
   * Create wavy image:
   */

  lpeakim(imdiff);

  /*
   * Write the output image:
   */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(imageout);








Sep 19 20:37 1995   Page 167


}

::::::::::::::
polarim.c
::::::::::::::
/* POLARIM.C - Perform polarization correction on a diffraction image.

   Author: Mike Wall
   Date: 4/26/94
   Version: 1.

   "polarim <image in> <image out> <x origin> <y origin>
      <distance[mm]> <polarization> <offset angle>"

   Input is diffraction image.  Output is polarization corrected image.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff;

  struct rccoords
	origin;

  float
    polarization_offset,
    polarization,
    distance_mm;

/*
 * Set input line defaults:
 */
  origin.r = DEFAULT_IMAGE_ORIGIN;
  origin.c = DEFAULT_IMAGE_ORIGIN;
  distance_mm = DEFAULT_DISTANCE_MM;
  polarization = DEFAULT_POLARIZATION;
  imagein = stdin;
  imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 8:
	  polarization_offset = atof(argv[7]);







Sep 19 20:37 1995   Page 168


	  case 7:
	  polarization = atof(argv[6]);
	  case 6:
	  distance_mm = atof(argv[5]);
	  case 5:
	  origin.r = (RCCOORDS_DATA)atol(argv[4]);
	  case 4:
	  origin.c = (RCCOORDS_DATA)atol(argv[3]);
	  case 3:
	  if (strcmp(argv[2], "-") == 0) {
	    imageout = stdout;
	  }
	  else {
	    if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	      printf("Can't open %s.",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1], "-") == 0) {
	    imagein = stdin;
	  }
	  else {
	    if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	      printf("Can't open %s.",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: polarim <image in> <image out> "
		 "<x origin> <y origin> <distance [mm]> <polarization> "
		 "<offset angle>\n\n");
	  exit(0);
	}

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

  /*
   * Set the origin for the image:
   */

  imdiff->origin = origin;

  /*
   * Set sample-to-detector distance for the image
   */

  imdiff->distance_mm = distance_mm;







Sep 19 20:37 1995   Page 169



  /*
   * Set the polarization of the beam:
   */

  imdiff->polarization = polarization;
  imdiff->polarization_offset = polarization_offset;

  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Polarization correct image:
   */

  lpolarim(imdiff);

  /*
   * Write the output image:
   */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(imageout);

}


::::::::::::::
prtchr.c
::::::::::::::
#include<stdio.h>







Sep 19 20:37 1995   Page 170


#include<stdlib.h>

main()
{
	char
		ch=0;
	do {
		putchar(ch);
		ch = getchar();
	} while (ch != 255);	
}


::::::::::::::
punchim.c
::::::::::::::
/* PUNCH.C - Mark all pixels inside a window in an image with an ignore tag.

   Author: Mike Wall
   Date: 5/12/94
   Version: 1.

   "punchim <image in> <x_lower_bound> <x_upper_bound> <y_lower_bound>
		<y_upper_bound> <image out>

   Input is diffraction image.  Output is 16-bit
     image of specified size (1024 x 1024 default), with pixels inside bounds
     marked to be ignored.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  char
    error_msg[LINESIZE];

  long
	i,
	ii;

  DIFFIMAGE
	*imdiff;

  struct rccoords
	upper_bound,
	lower_bound;

/*
 * Set input line defaults:
 */







Sep 19 20:37 1995   Page 171


	upper_bound.r = DEFAULT_WINDOW_UPPER;
	upper_bound.c = DEFAULT_WINDOW_UPPER;
	lower_bound.c = DEFAULT_WINDOW_LOWER;
	lower_bound.c = DEFAULT_WINDOW_LOWER;
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 7:
			if (strcmp(argv[6], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[6],"wb")) == NULL ) {
				printf("Can't open %s.",argv[6]);
				exit(0);
			 }
			}
		case 6:
			upper_bound.r = (RCCOORDS_DATA)atol(argv[5]);
		case 5:
			lower_bound.r = (RCCOORDS_DATA)atol(argv[4]);
		case 4:
			upper_bound.c = (RCCOORDS_DATA)atol(argv[3]);
		case 3:
			lower_bound.c = (RCCOORDS_DATA)atol(argv[2]);
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: punchim <image in> <x_lower_bound> "
			       "<x_upper_bound> <y_lower_bound> "
			       "<y_upper_bound> <image out> \n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }








Sep 19 20:37 1995   Page 172


/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

/*
 * Set window parameters:
 */

  imdiff->window_upper = upper_bound;
  imdiff->window_lower = lower_bound;

/*
 * Mark pixels outside window as ignored:
 */

  lpunchim(imdiff);

/*
 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

CloseShop:

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
rad2s.c
::::::::::::::
#include<stdlib.h>
#include<math.h>
#include<stdio.h>

void main()
{
	char input_string[121];







Sep 19 20:37 1995   Page 173


	float x,y;
	float res;

	while (fgets(input_string,120,stdin) != NULL) {
		sscanf(input_string,"%g %g",&x,&y);
		res = 2*fsin(.5*atanf(.0508/56.4*x))/.91;
		printf("%e %e\n",res,y);
	}
}	
::::::::::::::
ratioim.c
::::::::::::::
/* RATIOIM.C - Scale one image to another in radial shells.

   Author: Mike Wall
   Date: 4/14/94
   Version: 1.

   "ratioim <input image 1> <x origin 1> <y origin 1> <input image 2> <x origin 2> <y origin 2> <output 1>"

   Input two diffraction images in TIFF TV6 format.  Output is rfile
   with ratio as function of radius.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein1,
	*imagein2,
	*outfile;

  size_t
    i;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

  struct rccoords
	origin1,
	origin2;

  int
	got_r2 = 0,
	got_c2 = 0;
/*
 * Set input line defaults:
 */
	
	imagein1 = stdin;
	imagein2 = stdin;
	outfile = stdout;
	origin1.r = DEFAULT_IMAGE_ORIGIN;







Sep 19 20:37 1995   Page 174


	origin1.c = DEFAULT_IMAGE_ORIGIN;
	origin2.r = DEFAULT_IMAGE_ORIGIN;
	origin2.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 8:
			if (strcmp(argv[7], "-") == 0) {
				outfile = stdout;
			}
			else {
			 if ( (outfile = fopen(argv[7],"wb")) == NULL ) {
				printf("Can't open %s.",argv[7]);
				exit(0);
			 }
			}
		case 7:
			origin2.r = (RCCOORDS_DATA)atoi(argv[6]);
			got_r2 = 1;
		case 6:
			origin2.c = (RCCOORDS_DATA)atoi(argv[5]);
			got_c2 = 1;
		case 5:
			if (strcmp(argv[4], "-") == 0) {
				imagein2 = stdin;
			}
			else {
			 if ( (imagein2 = fopen(argv[4],"rb")) == NULL ) {
				printf("Can't open %s.",argv[4]);
				exit(0);
			 }
			}
		case 4:
			origin1.r = (RCCOORDS_DATA)atoi(argv[3]);
			if (got_r2 == 0) origin2.r = origin1.r;
		case 3:
			origin1.c = (RCCOORDS_DATA)atoi(argv[2]);
			if (got_c2 == 0) origin2.c = origin1.c;
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein1 = stdin;
			}
			else {
			 if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: ratioim <input image 1> "
				"<x origin 1> <y origin 1> <input image 2> "
				"<x origin 2> <y origin 2> "
				"<output scale>\n\n ");







Sep 19 20:37 1995   Page 175


			exit(0);
	}
/*
 * Initialize diffraction images:
 */

  if (((imdiff1 = linitim()) == NULL) || ((imdiff2 = linitim()) == NULL)) {
    perror("Couldn't initialize diffraction images.\n\n");
    exit(0);
  }

/*
 * Set main defaults:
 */

	imdiff1->origin = origin1;
	imdiff2->origin = origin2;


 /*
  * Read diffraction image:
  */

  imdiff1->infile = imagein1;
  if (lreadim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

  imdiff2->infile = imagein2;
  if (lreadim(imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

  if (lratioim(imdiff1,imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

/*
 * Output rfile:
 */

  printf("\nLength = %ld\n",imdiff2->rfile_length);
  for(i=0; i<= imdiff2->rfile_length; i++) {
    imdiff2->rfile[i] = imdiff2->imscaler[i];
  }
  imdiff2->outfile = outfile;
  if(lwriterf(imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }


 CloseShop:







Sep 19 20:37 1995   Page 176



/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(imagein1);
  fclose(imagein2);
  fclose(outfile);
}

::::::::::::::
rf2char.c
::::::::::::::
/* RF2CHAR.C - Convert an ascii rfile from tv6 to a list of 8-bit integers,
		stripping the x-axis.
   Author: Mike Wall
   Date: 3/25/94
   Version: 1.0
   Description:

		"rf2char <lower threshold> <upper threshold>"

		Input is an ascii rfile.
		Output is an 8-bit list of densitometry values.
*/

#define DEFAULT_LOWER_THRESHOLD 0
#define DEFAULT_UPPER_THRESHOLD 32767
#define MAX_VALUE 32767

#include<mwmask.h>

void main(int argc, char *argv[])
{
	short
	    upper_threshold = DEFAULT_UPPER_THRESHOLD,
	    lower_threshold = DEFAULT_LOWER_THRESHOLD;

	float
		value,
		scale;

	int
		index;

	char
		output_value,
		inline[LINESIZE];








Sep 19 20:37 1995   Page 177


	switch(argc) {
		case 3:
		upper_threshold = atoi(argv[2]);
		case 2:
		lower_threshold = atoi(argv[1]);
		break;
		default:
			printf("\nUsage: rf2char <lower threshold> "
					"<upper threshold>\n\n");
			exit(0);
	}
	scale = 255./(float)(upper_threshold - lower_threshold);
	while (fgets(inline,LINESIZE,stdin) != NULL) {
		sscanf(inline,"%d %g", &index, &value);
		if (value < (float)lower_threshold) {
			output_value = 0;
		}
		else if (value > (float)upper_threshold) {
			output_value = 255;
		}
		else {
			output_value = (char)((scale * (value -
				(float)lower_threshold)));
		}
		fwrite(&output_value, sizeof(char), 1, stdout);
	}
}
::::::::::::::
rf2lt.c
::::::::::::::
/* SUBRFLT.C - Generate a lattice from an rfile.

   Author: Mike Wall
   Date: 3/3/95
   Version: 1.

   Usage:
   		"rf2lt <input rfile> <input lattice> <output lattice>"

		Input is a radial intensity distribution and an input
			lattice.  Output is a lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile,
	*latticein,
	*latticeout;

  char
    error_msg[LINESIZE];

  size_t







Sep 19 20:37 1995   Page 178


	i,
	j,
	k,
	num_read,
	num_wrote;

  LAT3D
	*lat;

  RFILE_DATA_TYPE *rfile;

/*
 * Set input line defaults:
 */
	
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3],"-") == 0) {
				latticeout = stdout;
			}
			else {
			 if ((latticeout = fopen(argv[3],"wb")) == NULL) {
				printf("\nCan't open %s.\n\n",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2],"-") == 0) {
				latticein = stdin;
			}
			else {
			 if ( (latticein = fopen(argv[2],"rb")) == NULL ) {
				printf("\nCan't open %s.\n\n",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ((infile = fopen(argv[1],"rb")) == NULL) {
				printf("\nCan't open %s.\n\n",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: rf2lt <input file> <input lattice>"
				"<output lattice>\n\n");
			exit(0);
	}

  /*
   * Initialize lattice:







Sep 19 20:37 1995   Page 179


   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Read in rfile:
 */

 while ((num_read = fread(&lat->rfile[i], sizeof(RFILE_DATA_TYPE), 1,
				infile)) == 1) {
	i++;
 }

 lat->rfile_length = i;

/*
 * Generate the subtracted image:
 */

  lrf2lt(lat);

/*
 * Write lattice to output file:
 */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */








Sep 19 20:37 1995   Page 180


  fclose(infile);
  fclose(latticein);
  fclose(latticeout);
}

::::::::::::::
rmpkim.c
::::::::::::::
/* RMPKIM.C - Remove peaks by replacing them with background pixel values..

   Author: Mike Wall   Modified by:Fredrik Osterberg
   Date: 5/13/93
   Version: 1.

   "rmpkim <input file> <image in> <image out> <hsize> <vsize>"

   Input is ascii coordinates file.  Output is 16-bit
   image of specified size (1024 x 1024 default).

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile,
	*imagein,
	*imageout;

  char
    error_msg[LINESIZE];

  size_t
    num_wrote,
    num_read;

  long
	i,
	ii;

  RCCOORDS_DATA
	radius;

  DIFFIMAGE
	*imdiff;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:







Sep 19 20:37 1995   Page 181


 */
	switch(argc) {
		case 5:
			radius = (RCCOORDS_DATA)atoi(argv[4]);
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ( (infile = fopen(argv[1],"r")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: maskimg <input file> "
				"<image in> <image out> \n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }









Sep 19 20:37 1995   Page 182


  /*
   * Generate mask:
   */

	imdiff->mask_inner_radius = radius;
	imdiff->mask_outer_radius = radius;
	lgetanls(imdiff);
	if (imdiff->mask_count == 0) {
		printf("\nNo points in mask generated.\n");
		goto CloseShop;
	}

/*
 * Read in peaks from input file:
 */
	imdiff->infile = infile;
	lgetpks(imdiff);
/*
 * Generate overload list:
 */

	lgetovld(imdiff);

  /*
   *  Step through the peak table and punch out holes in the image.
   */
printf("\nNumber of peaks: %ld\n\n",(long)imdiff->peak_count);
	for(i=0;i<imdiff->peak_count;i++) {
		imdiff->pos.c = (short)imdiff->peak[i].y;
		imdiff->pos.r = (short)imdiff->peak[i].x;
		lrmpkim(imdiff);
	}
	imdiff->mask_inner_radius = 0;
	imdiff->mask_outer_radius = DEFAULT_OVERLOAD_RADIUS;
	lgetanls(imdiff);
	imdiff->punch_tag = imdiff->ignore_tag;
	for(i=0;i<imdiff->overload_count;i++) {
		imdiff->pos = imdiff->overload[i];
		lpunch(imdiff);
	}

/*
 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

CloseShop:

  lfreeim(imdiff);

/*







Sep 19 20:37 1995   Page 183


 * Close files:
 */

  fclose(infile);
  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
scaleim.c
::::::::::::::
/* SCALEIM.C - Scale one image to another in radial shells.

   Author: Mike Wall
   Date: 4/7/94
   Version: 1.

   "scaleim <input image 1> <x origin 1> <y origin 1> <input image 2> <x origin 2> <y origin 2> <output 1> <output 2>"

   Input two diffraction images in TIFF TV6 format.  Output is two rfiles
   with scale and offset as function of radius.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein1,
	*imagein2,
	*outfile1,
	*outfile2;

  size_t
    i,
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

  struct rccoords
	origin1,
	origin2;

  int
	got_r2 = 0,
	got_c2 = 0;
/*
 * Set input line defaults:
 */
	
	imagein1 = stdin;







Sep 19 20:37 1995   Page 184


	imagein2 = stdin;
	outfile1 = stdout;
	outfile2 = stdout;
	origin1.r = DEFAULT_IMAGE_ORIGIN;
	origin1.c = DEFAULT_IMAGE_ORIGIN;
	origin2.r = DEFAULT_IMAGE_ORIGIN;
	origin2.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 9:
			if (strcmp(argv[8], "-") == 0) {
				outfile2 = stdout;
			}
			else {
			 if ( (outfile2 = fopen(argv[8],"wb")) == NULL ) {
				printf("Can't open %s.",argv[8]);
				exit(0);
			 }
			}
		case 8:
			if (strcmp(argv[7], "-") == 0) {
				outfile1 = stdout;
			}
			else {
			 if ( (outfile1 = fopen(argv[7],"wb")) == NULL ) {
				printf("Can't open %s.",argv[7]);
				exit(0);
			 }
			}
		case 7:
			origin2.r = (RCCOORDS_DATA)atoi(argv[6]);
			got_r2 = 1;
		case 6:
			origin2.c = (RCCOORDS_DATA)atoi(argv[5]);
			got_c2 = 1;
		case 5:
			if (strcmp(argv[4], "-") == 0) {
				imagein2 = stdin;
			}
			else {
			 if ( (imagein2 = fopen(argv[4],"rb")) == NULL ) {
				printf("Can't open %s.",argv[4]);
				exit(0);
			 }
			}
		case 4:
			origin1.r = (RCCOORDS_DATA)atoi(argv[3]);
			if (got_r2 == 0) origin2.r = origin1.r;
		case 3:
			origin1.c = (RCCOORDS_DATA)atoi(argv[2]);
			if (got_c2 == 0) origin2.c = origin1.c;
		case 2:
			if (strcmp(argv[1], "-") == 0) {







Sep 19 20:37 1995   Page 185


				imagein1 = stdin;
			}
			else {
			 if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: scaleim <input image 1> "
				"<x origin 1> <y origin 1> <input image 2> "
				"<x origin 2> <y origin 2> <output scale> "
				"<output offset>\n\n");
			exit(0);
	}
/*
 * Initialize diffraction images:
 */

  if (((imdiff1 = linitim()) == NULL) || ((imdiff2 = linitim()) == NULL)) {
    perror("Couldn't initialize diffraction images.\n\n");
    exit(0);
  }

printf("scaleim:Made it past diffraction image initialization.\n\n");
/*
 * Set main defaults:
 */

	imdiff1->origin = origin1;
	imdiff2->origin = origin2;


 /*
  * Read diffraction image:
  */

  imdiff1->infile = imagein1;
  if (lreadim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

  imdiff2->infile = imagein2;
  if (lreadim(imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

  if (lscaleim(imdiff1,imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

/*







Sep 19 20:37 1995   Page 186


 * Output rfiles:
 */

  printf("\nLength = %ld\n",imdiff2->rfile_length);
  for(i=0; i<= imdiff2->rfile_length; i++) {
    fwrite(&imdiff2->imscaler[i], sizeof(RFILE_DATA_TYPE), 1, outfile1);
    fwrite(&imdiff2->imoffsetr[i], sizeof(RFILE_DATA_TYPE), 1, outfile2);
  }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(imagein1);
  fclose(imagein2);
  fclose(outfile1);
  fclose(outfile2);
}

::::::::::::::
scalelt.c
::::::::::::::
/* SCALELT.C - Find the best scale factor relating two input lattices.

   Author: Mike Wall
   Date: 3/21/95
   Version: 1.

   Usage:
   		"scalelt <input lattice 1> <input lattice 2>"

		Input is two 3D lattices.  Output is a scale factor.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2;

  char
    error_msg[LINESIZE];

  LAT3D
    *lat1,







Sep 19 20:37 1995   Page 187


    *lat2;

  size_t
    inner_radius,
    outer_radius;

  /*
   * Set input line defaults:
   */

  latticein1 = stdin;
  latticein2 = stdin;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 5:
    outer_radius = atol(argv[4]);
    case 4:
    inner_radius = atol(argv[3]);
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      latticein2 = stdin;
    }
    else {
      if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein1 = stdin;
    }
    else {
      if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: scalelt <input lattice 1> <input lattice 2> "
	   "<inner radius> <outer radius>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if (((lat1 = linitlt()) == NULL) || ((lat2 = linitlt()) == NULL)) {
    perror("Couldn't initialize lattices.\n\n");
    exit(0);
  }







Sep 19 20:37 1995   Page 188



  /*
   * Read in lattices:
   */

  lat1->infile = latticein1;
  if (lreadlt(lat1) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  lat2->infile = latticein2;
  if (lreadlt(lat2) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the normalized difference squared:
 */

  lat1->inner_radius = inner_radius;
  lat1->outer_radius = outer_radius;
  lscalelt(lat1,lat2);

/*
 * Write rfile to output file:
 */

  printf("%f\n",lat1->rfile[0]);

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat1);
  lfreelt(lat2);

  /*
   * Close files:
   */

  fclose(latticein1);
  fclose(latticein2);
}

::::::::::::::
scalerf.c
::::::::::::::
/* SCALEIM.C - Scale one image to another in radial shells.

   Author: Mike Wall
   Date: 4/7/94
   Version: 1.







Sep 19 20:37 1995   Page 189



   "scaleim <input image 1> <x origin 1> <y origin 1> <input image 2> <x origin 2> <y origin 2> <output 1> <output 2>"

   Input two diffraction images in TIFF TV6 format.  Output is two rfiles
   with scale and offset as function of radius.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein1,
	*imagein2,
	*outfile1,
	*outfile2;

  size_t
    i,
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

  struct rccoords
	origin1,
	origin2;

  int
	got_r2 = 0,
	got_c2 = 0;
/*
 * Set input line defaults:
 */
	
	imagein1 = stdin;
	imagein2 = stdin;
	outfile1 = stdout;
	outfile2 = stdout;
	origin1.r = DEFAULT_IMAGE_ORIGIN;
	origin1.c = DEFAULT_IMAGE_ORIGIN;
	origin2.r = DEFAULT_IMAGE_ORIGIN;
	origin2.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 9:
			if (strcmp(argv[8], "-") == 0) {
				outfile2 = stdout;
			}
			else {







Sep 19 20:37 1995   Page 190


			 if ( (outfile2 = fopen(argv[8],"wb")) == NULL ) {
				printf("Can't open %s.",argv[8]);
				exit(0);
			 }
			}
		case 8:
			if (strcmp(argv[7], "-") == 0) {
				outfile1 = stdout;
			}
			else {
			 if ( (outfile1 = fopen(argv[7],"wb")) == NULL ) {
				printf("Can't open %s.",argv[7]);
				exit(0);
			 }
			}
		case 7:
			origin2.r = (RCCOORDS_DATA)atoi(argv[6]);
			got_r2 = 1;
		case 6:
			origin2.c = (RCCOORDS_DATA)atoi(argv[5]);
			got_c2 = 1;
		case 5:
			if (strcmp(argv[4], "-") == 0) {
				imagein2 = stdin;
			}
			else {
			 if ( (imagein2 = fopen(argv[4],"rb")) == NULL ) {
				printf("Can't open %s.",argv[4]);
				exit(0);
			 }
			}
		case 4:
			origin1.r = (RCCOORDS_DATA)atoi(argv[3]);
			if (got_r2 == 0) origin2.r = origin1.r;
		case 3:
			origin1.c = (RCCOORDS_DATA)atoi(argv[2]);
			if (got_c2 == 0) origin2.c = origin1.c;
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein1 = stdin;
			}
			else {
			 if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: scaleim <input image 1> "
				"<x origin 1> <y origin 1> <input image 2> "
				"<x origin 2> <y origin 2> <output scale> "
				"<output offset>\n\n");
			exit(0);
	}
/*







Sep 19 20:37 1995   Page 191


 * Initialize diffraction images:
 */

  if (((imdiff1 = linitim()) == NULL) || ((imdiff2 = linitim()) == NULL)) {
    perror("Couldn't initialize diffraction images.\n\n");
    exit(0);
  }

printf("scaleim:Made it past diffraction image initialization.\n\n");
/*
 * Set main defaults:
 */

	imdiff1->origin = origin1;
	imdiff2->origin = origin2;


 /*
  * Read diffraction image:
  */

  imdiff1->infile = imagein1;
  if (lreadim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

  imdiff2->infile = imagein2;
  if (lreadim(imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

  if (lscaleim(imdiff1,imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

/*
 * Output rfiles:
 */

  printf("\nLength = %ld\n",imdiff2->rfile_length);
  for(i=0; i<= imdiff2->rfile_length; i++) {
    fwrite(&imdiff2->imscaler[i], sizeof(RFILE_DATA_TYPE), 1, outfile1);
    fwrite(&imdiff2->imoffsetr[i], sizeof(RFILE_DATA_TYPE), 1, outfile2);
  }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);







Sep 19 20:37 1995   Page 192



/*
 * Close files:
 */

  fclose(imagein1);
  fclose(imagein2);
  fclose(outfile1);
  fclose(outfile2);
}

::::::::::::::
see.c
::::::::::::::
/* SEE.C - Convert a 16-bit 1024x1024 TV6 tiff image to an 8-bit tiff image.
		Scale to window given at input command line.
   Author: Mike Wall
   Date: 2/25/94
   Version: 1.0
   Description:

		"see <input file> <output file> <lower threshold>
			<upper threshold>"

		Input is a 16-bit 1024x1024 TV6 tiff image.
		Output is an 8-bit tiff image.
*/

#define LINESIZE 120
#define DEFAULT_HEADER_LENGTH 4096
#define DEFAULT_FILE_SIZE 2101248
#define DEFAULT_LOWER_THRESHOLD 256
#define DEFAULT_UPPER_THRESHOLD 32767
#define MAX_VALUE 32767

#include<stdio.h>

union data_union {
	short two_byte;
	struct {
		char low_byte;
		char high_byte;
	} one_byte;
};

void main(int argc, char *argv[])
{
	FILE
	    *f_in,
	    *f_out;

	char
	*filename;

	char
	*outstream,







Sep 19 20:37 1995   Page 193


	    *header;

	short
	upper_threshold = DEFAULT_UPPER_THRESHOLD,
	    lower_threshold = DEFAULT_LOWER_THRESHOLD,
		pix_value;

	size_t
	    filesize,
	    imagesize,
	    imagelength,
	    num_read,
	    num_wrote,
	    i,
	    header_length = DEFAULT_HEADER_LENGTH;

	float
		scale;

	short
	*instream;

	union data_union
	pix;

	filename = (char *)malloc(sizeof(char)*(LINESIZE+1));
	if (!filename) {
		printf("Can't allocate image arrays.  Exiting.\n");
		exit(0);
	}
	f_out = stdout;
	switch(argc) {
		case 5:
		strcpy(filename,argv[4]);
		if (strcmp(filename,"-") == 0) {
			f_out = stdout;
		}
		else
		if ( (f_out = fopen(filename,"wb")) == NULL ) {
			printf("Can't open %s.",filename);
			exit(0);
		}
		case 4:
		upper_threshold = atoi(argv[3]);
		case 3:
		lower_threshold = atoi(argv[2]);
		case 2:
		/*
 * Open input and output files:
 */

		strcpy(filename,argv[1]);
		if (strcmp(filename,"-") == 0) {
			f_in = stdin;
		}
		else







Sep 19 20:37 1995   Page 194


		if ( (f_in = fopen(filename,"rb")) == NULL ) {
			printf("Can't open %s.",filename);
			exit(0);
		}
		break;
	default:

		printf("\n     Usage: see <input file> "
		    "<lower threshold> "
		    "<upper threshold> <output file>\n\n");
		exit(0);
	}

	/*
 * Allocate memory for the header:
 */

	header = (char *)malloc(sizeof(char)*(header_length+1));
	if (!header) {
		printf("Can't allocate header.  Exiting.\n");
		exit(0);
	}

	/*
 * Read the input image:
 */

	filesize = DEFAULT_FILE_SIZE;
	imagesize = filesize-header_length;
	imagelength = imagesize/2;
	outstream = (char *)malloc(sizeof(char)*(imagelength+1));
	instream = (short *)malloc(sizeof(short)*(imagelength+1));
	if (!(outstream && instream)) {
		printf("Can't allocate image arrays.  Exiting.\n");
		exit(0);
	}
	num_read = fread(header,sizeof(char),header_length,f_in);
	/*
 * Modify header to indicate 8-bit tiff:
 */

	header[0x88] = 0x08;		/* Bits per pixel */
	header[0xDE] = 0x10;		/* Strip size change */
	header[0x178] = 0x08;		/* TV6 Significant bpp */

	num_read = fread(instream,sizeof(short),imagelength,f_in);
	if (ferror(f_in)) {
		printf("Error reading file %s.",filename);
	}


	/*
 * Generate output image:
 */

	scale = 255. / (float)(upper_threshold - lower_threshold);







Sep 19 20:37 1995   Page 195


	i = 0;
	while (i < imagelength) {
		pix.two_byte = instream[i];
		pix_value = (short)pix.one_byte.high_byte * 256 +
			(short)pix.one_byte.low_byte;
		if ((pix_value < lower_threshold) || (pix_value >= 32766)) {
			outstream[i] = 0;
		}
		else if (pix_value > upper_threshold) {
			outstream[i] = 255;
		}
		else {
			outstream[i] = (char)((scale * (pix_value -
				lower_threshold)));
		}
		i++;
	}


	/*
 * Write TIFF header:
 */

	num_wrote = fwrite(header, sizeof(char), header_length, f_out);

	/*
 * Write the output image:
 */

	num_wrote = fwrite(outstream, sizeof(char), imagelength, f_out);

	/*
 * Free allocated memory:
 */

	free((char *)filename);
	free((short *)instream);
	free((char *)outstream);
	free((char *)header);
}
::::::::::::::
seecat.c
::::::::::::::
/* SEE.C - Convert a 16-bit 1024x1024 TV6 tiff image to an 8-bit tiff image.
		Scale to window given at input command line.
   Author: Mike Wall
   Date: 2/25/94
   Version: 1.0
   Description:

		"see <input file> <output file> <lower threshold>
			<upper threshold>"

		Input is a 16-bit 1024x1024 TV6 tiff image.
		Output is an 8-bit tiff image (to standard output).
*/







Sep 19 20:37 1995   Page 196



#define LINESIZE 120
#define DEFAULT_HEADER_LENGTH 4096
#define DEFAULT_FILE_SIZE 2101248
#define DEFAULT_LOWER_THRESHOLD 0
#define DEFAULT_UPPER_THRESHOLD 32767
#define MAX_VALUE 32767

#include<stdio.h>

union data_union {
	short two_byte;
	struct {
		char low_byte;
		char high_byte;
	} one_byte;
};

void main(int argc, char *argv[])
short argc;
char *argv[];
{
	FILE
	    *f_in;

	char
	*filename;

	char
	*outstream,
	    *header;

	short
	upper_threshold = DEFAULT_UPPER_THRESHOLD,
	    lower_threshold = DEFAULT_LOWER_THRESHOLD,
		pix_value;

	size_t
	    filesize,
	    imagesize,
	    imagelength,
	    num_read,
	    num_wrote,
	    i,
	    header_length = DEFAULT_HEADER_LENGTH;

	unsigned short
		handle,
		max,
		min,
		scaled_num;

	float
		scale;

	short







Sep 19 20:37 1995   Page 197


	*instream;

	union data_union
	pix;

	filename = (char *)malloc(sizeof(char)*(LINESIZE+1));
	if (!filename) {
		printf("Can't allocate image arrays.  Exiting.\n");
		exit(0);
	}
	switch(argc) {
		case 4:
		upper_threshold = atoi(argv[3]);
		case 3:
		lower_threshold = atoi(argv[2]);
		case 2:
		/*
 * Open input file:
 */

		strcpy(filename,argv[1]);
		if ( (f_in = fopen(filename,"rb")) == NULL ) {
			printf("Can't open %s.",filename);
			exit(0);
		}
		break;
	default:

		printf("\n     Usage: seecat <input file> "
		    "<lower threshold> "
		    "<upper threshold>\n");
		exit(0);
	}

	/*
 * Allocate memory for the header:
 */

	header = (char *)malloc(sizeof(char)*(header_length+1));
	if (!header) {
		printf("Can't allocate header.  Exiting.\n");
		exit(0);
	}

	/*
 * Read the input image:
 */

	/*	handle = fileno(f_in);
	if ((filesize = filelength(handle)) == 0) {
		printf("Can't get length of file.\n");
		exit(0);
	}
*/
	filesize = DEFAULT_FILE_SIZE;
	imagesize = filesize-header_length;







Sep 19 20:37 1995   Page 198


	imagelength = imagesize/2;
	outstream = (char *)malloc(sizeof(char)*(imagelength+1));
	instream = (short *)malloc(sizeof(short)*(imagelength+1));
	if (!(outstream && instream)) {
		printf("Can't allocate image arrays.  Exiting.\n");
		exit(0);
	}
	num_read = fread(header,sizeof(char),header_length,f_in);
	/*
 * Modify header to indicate 8-bit tiff:
 */

	header[0x88] = 0x08;		/* Bits per pixel */
	header[0xDE] = 0x10;		/* Strip size change */
	header[0x178] = 0x08;		/* TV6 Significant bpp */

	num_read = fread(instream,sizeof(short),imagelength,f_in);
	if (ferror(f_in)) {
		printf("Error reading file %s.",filename);
	}


	/*
 * Generate output image:
 */

	scale = 255. / (float)(upper_threshold - lower_threshold);
	i = 0;
	while (i < imagelength) {
		pix.two_byte = instream[i];
		pix_value = (short)pix.one_byte.high_byte * 256 +
			(short)pix.one_byte.low_byte;
		if (pix_value < lower_threshold) {
			outstream[i] = 0;
		}
		else if (pix_value > upper_threshold) {
			outstream[i] = 255;
		}
		else {
			outstream[i] = (char)((scale * (pix_value -
				lower_threshold)));
		}
		i++;
	}


	/*
 * Write TIFF header:
 */

/*	num_wrote = fwrite(header, sizeof(char), header_length, f_out);i*/
	for (i=0;i<=header_length;i++) {
		putchar(header[i]);
	}

	/*







Sep 19 20:37 1995   Page 199


 * Write the output image:
 */

/*	num_wrote = fwrite(outstream, sizeof(char), imagelength, f_out);i*/
	for (i=0;i<imagelength;i++) {
		putchar(outstream[i]);
	}

	/*
 * Free allocated memory:
 */

	free((char *)filename);
	free((short *)instream);
	free((char *)outstream);
	free((char *)header);
}
::::::::::::::
seesh.c
::::::::::::::
/* SEESH.C - Convert a 16-bit SHIM image to an 8-bit image.
		Scale to window given at input command line.
   Author: Mike Wall
   Date: 3/26/95
   Version: 1.0
   Description:

		"seesh <input file> <output file> <lower threshold>
			<upper threshold>"

		Input is a 16-bit SHIM image.
		Output is an 8-bit image.
*/

#define LINESIZE 120
#define DEFAULT_HEADER_LENGTH 0
#define DEFAULT_FILE_SIZE 131072
#define DEFAULT_LOWER_THRESHOLD 256
#define DEFAULT_UPPER_THRESHOLD 32767
#define MAX_VALUE 32767

#include<stdio.h>

union data_union {
	short two_byte;
	struct {
		char low_byte;
		char high_byte;
	} one_byte;
};

void main(int argc, char *argv[])
{
	FILE
	    *f_in,
	    *f_out;







Sep 19 20:37 1995   Page 200



	char
	*filename;

	char
	*outstream,
	    *header;

	short
	upper_threshold = DEFAULT_UPPER_THRESHOLD,
	    lower_threshold = DEFAULT_LOWER_THRESHOLD,
		pix_value;

	size_t
	    filesize,
	    imagesize,
	    imagelength,
	    num_read,
	    num_wrote,
	    i,
	    header_length = 0;

	float
		scale;

	short
	*instream;

	union data_union
	pix;

	filename = (char *)malloc(sizeof(char)*(LINESIZE+1));
	if (!filename) {
		printf("Can't allocate image arrays.  Exiting.\n");
		exit(0);
	}
	f_out = stdout;
	switch(argc) {
		case 5:
		strcpy(filename,argv[4]);
		if (strcmp(filename,"-") == 0) {
			f_out = stdout;
		}
		else
		if ( (f_out = fopen(filename,"wb")) == NULL ) {
			printf("Can't open %s.",filename);
			exit(0);
		}
		case 4:
		upper_threshold = atoi(argv[3]);
		case 3:
		lower_threshold = atoi(argv[2]);
		case 2:
		/*
 * Open input and output files:
 */







Sep 19 20:37 1995   Page 201



		strcpy(filename,argv[1]);
		if (strcmp(filename,"-") == 0) {
			f_in = stdin;
		}
		else
		if ( (f_in = fopen(filename,"rb")) == NULL ) {
			printf("Can't open %s.",filename);
			exit(0);
		}
		break;
	default:

		printf("\n     Usage: see <input file> "
		    "<lower threshold> "
		    "<upper threshold> <output file>\n\n");
		exit(0);
	}

	/*
 * Allocate memory for the header:
 */

	header = (char *)malloc(sizeof(char)*(header_length+1));
	if (!header) {
		printf("Can't allocate header.  Exiting.\n");
		exit(0);
	}

	/*
 * Read the input image:
 */

	filesize = DEFAULT_FILE_SIZE;
	imagesize = filesize-header_length;
	imagelength = imagesize/2;
	outstream = (char *)malloc(sizeof(char)*(imagelength+1));
	instream = (short *)malloc(sizeof(short)*(imagelength+1));
	if (!(outstream && instream)) {
		printf("Can't allocate image arrays.  Exiting.\n");
		exit(0);
	}
/*	num_read = fread(header,sizeof(char),header_length,f_in);/***/

	num_read = fread(instream,sizeof(short),imagelength,f_in);
	if (ferror(f_in)) {
		printf("Error reading file %s.",filename);
	}


	/*
 * Generate output image:
 */

	scale = 255. / (float)(upper_threshold - lower_threshold);
	i = 0;







Sep 19 20:37 1995   Page 202


	while (i < imagelength) {
		pix.two_byte = instream[i];
		pix_value = (short)pix.one_byte.high_byte * 256 +
			(short)pix.one_byte.low_byte;
		if ((pix_value < lower_threshold) || (pix_value >= 32766)) {
			outstream[i] = 0;
		}
		else if (pix_value > upper_threshold) {
			outstream[i] = 255;
		}
		else {
			outstream[i] = (char)((scale * (pix_value -
				lower_threshold)));
		}
		i++;
	}


	/*
 * Write TIFF header:
 */

/*	num_wrote = fwrite(header, sizeof(char), header_length, f_out);/***/

	/*
 * Write the output image:
 */

	num_wrote = fwrite(outstream, sizeof(char), imagelength, f_out);

	/*
 * Free allocated memory:
 */

	free((char *)filename);
	free((short *)instream);
	free((char *)outstream);
	free((char *)header);
}





::::::::::::::
shim4lt.c
::::::::::::::
/* SHIM4LT.C - Generate an image of the full angular distribution of */
/* intensity in a specified spherical shell of a lattice.

   Author: Mike Wall
   Date: 3/23/95
   Version: 1.

   Usage:
   		"shim4lt <input lattice> <output shim> <inner







Sep 19 20:37 1995   Page 203


		radius> <outer radius>"

		Input is a 3D lattice.  Output is a shell image.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *shimout,
    *latticein;

  char
    error_msg[LINESIZE];

  LAT3D
    *lat;

  size_t
    index,
    i,
    j,
    k,
    *histogram,
    r,
    inner_radius,
    outer_radius;

  struct ijkcoords rvec;

  struct xyzcoords rfloat;

  float
    rscale;

  /*
   * Set input line defaults:
   */

  latticein = stdin;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 5:
    outer_radius = atol(argv[4]);
    case 4:
    inner_radius = atol(argv[3]);
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      shimout = stdout;
    }
    else {
      if ( (shimout = fopen(argv[2],"w")) == NULL ) {







Sep 19 20:37 1995   Page 204


	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein = stdin;
    }
    else {
      if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: shim4lt <input lattice> <output shim> "
	   "<inner radius> <outer radius>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattices:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  /*
   * Generate shell image:
   */

  lat->inner_radius = inner_radius;
  lat->outer_radius = outer_radius;
  lshim4lt(lat);

  /*
   * Write shell image to a file:
   */

  lat->outfile = shimout;
  lwritesh(lat);

CloseShop:







Sep 19 20:37 1995   Page 205



  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(shimout);
}

::::::::::::::
shimlt.c
::::::::::::::
/* SHIMLT.C - Generate an image of a reduced angular distribution of */
/* intensity in a specified spherical shell of a lattice.

   Author: Mike Wall
   Date: 3/23/95
   Version: 1.

   Usage:
   		"shimlt <input lattice> <output shim> <inner
		radius> <outer radius>"

		Input is a 3D lattice.  Output is a shell image.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *shimout,
    *latticein;

  char
    error_msg[LINESIZE];

  LAT3D
    *lat;

  size_t
    index,
    i,
    j,
    k,
    *histogram,
    r,
    inner_radius,
    outer_radius;








Sep 19 20:37 1995   Page 206


  struct ijkcoords rvec;

  struct xyzcoords rfloat;

  float
    rscale;

  /*
   * Set input line defaults:
   */

  latticein = stdin;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 5:
    outer_radius = atol(argv[4]);
    case 4:
    inner_radius = atol(argv[3]);
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      shimout = stdout;
    }
    else {
      if ( (shimout = fopen(argv[2],"w")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein = stdin;
    }
    else {
      if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: shimlt <input lattice> <output shim> "
	   "<inner radius> <outer radius>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }







Sep 19 20:37 1995   Page 207



  /*
   * Read in lattices:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  /*
   * Generate shell image:
   */

  lat->inner_radius = inner_radius;
  lat->outer_radius = outer_radius;
  lshimlt(lat);

  /*
   * Write shell image to a file:
   */

  lat->outfile = shimout;
  lwritesh(lat);

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(shimout);
}

::::::::::::::
smthim.c
::::::::::::::
/* SMTHIM.C - Smooth an image.

   Author: Mike Wall   Modified by:Fredrik Osterberg
   Date: 4/11/93
   Version: 1.

   "smthim <image in> <image out> <hsize> <vsize>"

   Input is ascii coordinates file.  Output is 16-bit
   image of specified size (1024 x 1024 default).








Sep 19 20:37 1995   Page 208


   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  DIFFIMAGE
	*imdiff;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: smthim "
				"<image in> <image out> \n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {







Sep 19 20:37 1995   Page 209


    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

/*
 * Smooth image:
 */

  lsmthim(imdiff);

/*
 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

CloseShop:

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
solidlt.c
::::::::::::::
/* SOLIDLT.C - Apply solid angle correction to lattice.

   Author: Mike Wall
   Date: 3/25/95
   Version: 1.

   Usage:
   		"solidlt <input lattice> <output lattice>"
		
		Input is a lattice.  Output is a lattice.







Sep 19 20:37 1995   Page 210


		*/

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_read,
    num_wrote;

  LAT3D
    *lat;

  RFILE_DATA_TYPE
    *rfile;

  /*
   * Set input line defaults:
   */
  latticein = stdin;
  latticeout = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      latticeout = stdout;
    }
    else {
      if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein = stdin;
    }
    else {
      if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }







Sep 19 20:37 1995   Page 211


    break;
    default:
    printf("\n Usage: solidlt <input lattice> <output lattice>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  /*
   * Generate the corrected lattice:
   */

  lsolidlt(lat);

  /*
   * Write lattice to output file:
   */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(latticeout);
}







Sep 19 20:37 1995   Page 212



::::::::::::::
subim.c
::::::::::::::
/* SUBIM.C - Subtract one image from another.

   Author: Mike Wall
   Date: 4/18/94
   Version: 1.

   "subim <input image 1> <x origin 1> <y origin 1> <input image 2> <x origin 2> <y origin 2> <output image>"

   Input two diffraction images in TIFF TV6 format.  Output is the second
   subtracted from the first, taking origin translation into account.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein1,
	*imagein2,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

  struct rccoords
	origin1,
	origin2;

  int
	got_r2 = 0,
	got_c2 = 0;
/*
 * Set input line defaults:
 */
	
	imagein1 = stdin;
	imagein2 = stdin;
	imageout = stdout;
	origin1.r = DEFAULT_IMAGE_ORIGIN;
	origin1.c = DEFAULT_IMAGE_ORIGIN;
	origin2.r = DEFAULT_IMAGE_ORIGIN;
	origin2.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {







Sep 19 20:37 1995   Page 213


		case 8:
			if (strcmp(argv[7], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[7],"wb")) == NULL ) {
				printf("Can't open %s.",argv[7]);
				exit(0);
			 }
			}
		case 7:
			origin2.r = (RCCOORDS_DATA)atoi(argv[6]);
			got_r2 = 1;
		case 6:
			origin2.c = (RCCOORDS_DATA)atoi(argv[5]);
			got_c2 = 1;
		case 5:
			if (strcmp(argv[4], "-") == 0) {
				imagein2 = stdin;
			}
			else {
			 if ( (imagein2 = fopen(argv[4],"rb")) == NULL ) {
				printf("Can't open %s.",argv[4]);
				exit(0);
			 }
			}
		case 4:
			origin1.r = (RCCOORDS_DATA)atoi(argv[3]);
			if (got_r2 == 0) origin2.r = origin1.r;
		case 3:
			origin1.c = (RCCOORDS_DATA)atoi(argv[2]);
			if (got_c2 == 0) origin2.c = origin1.c;
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein1 = stdin;
			}
			else {
			 if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: subim <input image 1> "
				"<x origin 1> <y origin 1> <input image 2> "
				"<x origin 2> <y origin 2> "
				"<output image>\n\n");
			exit(0);
	}
/*
 * Initialize diffraction images:
 */

  if (((imdiff1 = linitim()) == NULL) || ((imdiff2 = linitim()) == NULL)) {
    perror("Couldn't initialize diffraction images.\n\n");







Sep 19 20:37 1995   Page 214


    exit(0);
  }

/*
 * Set main defaults:
 */

	imdiff1->origin = origin1;
	imdiff2->origin = origin2;


 /*
  * Read diffraction image:
  */

  imdiff1->infile = imagein1;
  if (lreadim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

  imdiff2->infile = imagein2;
  if (lreadim(imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

  if (lsubim(imdiff1,imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }


/*
 * Write the output image:
 */

  imdiff1->outfile = imageout;
  if(lwriteim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */








Sep 19 20:37 1995   Page 215


  fclose(imagein1);
  fclose(imagein2);
  fclose(imageout);
}

::::::::::::::
sublt.c
::::::::::::::
/* SUBLT.C - Calculate the voxel-by-voxel difference of two lattices.

   Author: Mike Wall
   Date: 7/7/95
   Version: 1.

   Usage:
   		"sublt <input lattice 1> <input lattice 2> <output
		lattice>"

		Input is two 3D lattices.  Output is a lattice which
		is the difference between the two.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_wrote;

  LAT3D
    *lat1,
    *lat2;

  RFILE_DATA_TYPE *rfile;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  latticein1 = stdin;
  latticein2 = stdin;
  latticeout = stdout;







Sep 19 20:37 1995   Page 216



  /*
   * Read information from input line:
   */
  switch(argc) {
    case 4:
    if ((latticeout = fopen(argv[3],"wb")) == NULL) {
      printf("\nCan't open %s.\n\n",argv[3]);
      exit(0);
    }
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      latticein2 = stdin;
    }
    else {
      if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {
      latticein1 = stdin;
    }
    else {
      if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: sublt <input lattice 1> <input lattice 2> "
	   "<output lattice>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if (((lat1 = linitlt()) == NULL) || ((lat2 = linitlt()) == NULL)) {
    perror("Couldn't initialize lattices.\n\n");
    exit(0);
  }

  /*
   * Read in lattices:
   */

  lat1->infile = latticein1;
  if (lreadlt(lat1) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }








Sep 19 20:37 1995   Page 217


  lat2->infile = latticein2;
  if (lreadlt(lat2) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the sum lattice:
 */

  lsublt(lat1,lat2);

  /*
   * Write lattice to output file:
   */

  lat1->outfile = latticeout;
  if (lwritelt(lat1) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat1);
  lfreelt(lat2);

  /*
   * Close files:
   */

  fclose(latticeout);
  fclose(latticein1);
  fclose(latticein2);
}

::::::::::::::
subrf.c
::::::::::::::
/* SUBRF.C - Subtract one rfile from another.

   Author: Mike Wall
   Date: 5/1/94
   Version: 1.

   "subrf <input rfile 1> <input rfile 2> <output rfile>"

   Input is two rfiles.  Output is second rfile subtracted from the
   first.

   */








Sep 19 20:37 1995   Page 218


#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile1,
	*infile2,
	*outfile;

  size_t
    i;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

/*
 * Set input line defaults:
 */
	
	infile1 = stdin;
	infile2 = stdin;
	outfile = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				outfile = stdout;
			}
			else {
			 if ( (outfile = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				infile2 = stdin;
			}
			else {
			 if ( (infile2 = fopen(argv[2],"rb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ( (infile1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: subrf <input rfile 1> "







Sep 19 20:37 1995   Page 219


				"<input rfile 2> <output rfile>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction images:
 */

  if ((imdiff1 = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

  if ((imdiff2 = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

 /*
  * Read in rfiles:
  */

   imdiff1->infile = infile1;
   if (lreadrf(imdiff1) != 0) {
     perror(imdiff1->error_msg);
     goto CloseShop;
   }

   imdiff2->infile = infile2;
   if (lreadrf(imdiff2) != 0) {
     perror(imdiff2->error_msg);
     goto CloseShop;
   }

/*
 * SUBTRACT rfiles:
 */

   lsubrf(imdiff1,imdiff2);

/*
 * Write the output rfile:
 */

   imdiff1->outfile = outfile;
   if(lwriterf(imdiff1) != 0) {
     perror(imdiff1->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */








Sep 19 20:37 1995   Page 220


  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(infile1);
  fclose(infile2);
  fclose(outfile);

}

::::::::::::::
subrfim.c
::::::::::::::
/* SUBRFIM.C - Subtract I(r) from a diffraction image.

   Author: Mike Wall
   Date: 4/4/94
   Version: 1.

   "subrfim <input file> <image in> <image out> <x origin> <y origin>"

   Input is rfile and image.  Output is 16-bit
   image with rfile subtracted.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile,
	*imagein,
	*imageout;

  size_t
    i,
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff;

  struct rccoords
	origin;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;
	origin.r = DEFAULT_IMAGE_ORIGIN;







Sep 19 20:37 1995   Page 221


	origin.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 6:
			origin.r = (RCCOORDS_DATA)atoi(argv[5]);
		case 5:
			origin.c = (RCCOORDS_DATA)atoi(argv[4]);
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ( (infile = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: subrfim <input file> "
				"<image in> <image out> <x origin> "
				"<y origin>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Set defaults:
 */








Sep 19 20:37 1995   Page 222


  imdiff->origin = origin;

 /*
  * Read diffraction image:
  */

   imdiff->infile = imagein;
   if (lreadim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

 /*
  * Read in rfile:
  */

  imdiff->infile = infile;
  if (lreadrf(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

/*
 * Subtract rfile from image:
 */

   lsubrfim(imdiff);

/*
 * Write the output image:
 */

   imdiff->outfile = imageout;
   if(lwriteim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(infile);
  fclose(imagein);
  fclose(imageout);

}








Sep 19 20:37 1995   Page 223


::::::::::::::
subrflt.c
::::::::::::::
/* SUBRFLT.C - Subtract a radial intensity distribution from each pixel
		in a 3D lattice.

   Author: Mike Wall
   Date: 3/28/93
   Version: 1.

   Usage:
   		"subrflt <input rfile> <input lattice> <output lattice>"

		Input is a radial intensity distribution and an input
			lattice.  Output is a lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile,
	*latticein,
	*latticeout;

  char
    error_msg[LINESIZE];

  size_t
	i,
	j,
	k,
	num_read,
	num_wrote;

  LAT3D
	*lat;

  RFILE_DATA_TYPE *rfile;

/*
 * Set input line defaults:
 */
	
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3],"-") == 0) {
				latticeout = stdout;
			}







Sep 19 20:37 1995   Page 224


			else {
			 if ((latticeout = fopen(argv[3],"wb")) == NULL) {
				printf("\nCan't open %s.\n\n",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2],"-") == 0) {
				latticein = stdin;
			}
			else {
			 if ( (latticein = fopen(argv[2],"rb")) == NULL ) {
				printf("\nCan't open %s.\n\n",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ((infile = fopen(argv[1],"rb")) == NULL) {
				printf("\nCan't open %s.\n\n",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: subrflt <input file> <input lattice>"
				"<output lattice>\n\n");
			exit(0);
	}

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Read in rfile:
 */

 while ((num_read = fread(&lat->rfile[i], sizeof(RFILE_DATA_TYPE), 1,
				infile)) == 1) {
	i++;
 }








Sep 19 20:37 1995   Page 225


 lat->rfile_length = i;

/*
 * Generate the subtracted image:
 */

  lsubrflt(lat);

/*
 * Write lattice to output file:
 */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(infile);
  fclose(latticein);
  fclose(latticeout);
}

::::::::::::::
sumim.c
::::::::::::::
/* SUMIM.C - Add one image to another.

   Author: Mike Wall
   Date: 4/6/95
   Version: 1.

   "sumim <input image 1> <x origin 1> <y origin 1> <input image 2> <x origin 2> <y origin 2> <output image>"

   Input two diffraction images in TIFF TV6 format.  Output is the
   sum, taking origin translation into account.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE







Sep 19 20:37 1995   Page 226


	*imagein1,
	*imagein2,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

  struct rccoords
	origin1,
	origin2;

  int
	got_r2 = 0,
	got_c2 = 0;
/*
 * Set input line defaults:
 */
	
	imagein1 = stdin;
	imagein2 = stdin;
	imageout = stdout;
	origin1.r = DEFAULT_IMAGE_ORIGIN;
	origin1.c = DEFAULT_IMAGE_ORIGIN;
	origin2.r = DEFAULT_IMAGE_ORIGIN;
	origin2.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 8:
			if (strcmp(argv[7], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[7],"wb")) == NULL ) {
				printf("Can't open %s.",argv[7]);
				exit(0);
			 }
			}
		case 7:
			origin2.r = (RCCOORDS_DATA)atoi(argv[6]);
			got_r2 = 1;
		case 6:
			origin2.c = (RCCOORDS_DATA)atoi(argv[5]);
			got_c2 = 1;
		case 5:
			if (strcmp(argv[4], "-") == 0) {
				imagein2 = stdin;
			}
			else {
			 if ( (imagein2 = fopen(argv[4],"rb")) == NULL ) {







Sep 19 20:37 1995   Page 227


				printf("Can't open %s.",argv[4]);
				exit(0);
			 }
			}
		case 4:
			origin1.r = (RCCOORDS_DATA)atoi(argv[3]);
			if (got_r2 == 0) origin2.r = origin1.r;
		case 3:
			origin1.c = (RCCOORDS_DATA)atoi(argv[2]);
			if (got_c2 == 0) origin2.c = origin1.c;
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein1 = stdin;
			}
			else {
			 if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: sumim <input image 1> "
				"<x origin 1> <y origin 1> <input image 2> "
				"<x origin 2> <y origin 2> "
				"<output image>\n\n");
			exit(0);
	}
/*
 * Initialize diffraction images:
 */

  if (((imdiff1 = linitim()) == NULL) || ((imdiff2 = linitim()) == NULL)) {
    perror("Couldn't initialize diffraction images.\n\n");
    exit(0);
  }

/*
 * Set main defaults:
 */

	imdiff1->origin = origin1;
	imdiff2->origin = origin2;


 /*
  * Read diffraction image:
  */

  imdiff1->infile = imagein1;
  if (lreadim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

  imdiff2->infile = imagein2;







Sep 19 20:37 1995   Page 228


  if (lreadim(imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

  if (lsumim(imdiff1,imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }


/*
 * Write the output image:
 */

  imdiff1->outfile = imageout;
  if(lwriteim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(imagein1);
  fclose(imagein2);
  fclose(imageout);
}

::::::::::::::
sumlt.c
::::::::::::::
/* SUMLT.C - Calculate the voxel-by-voxel sum of two lattices.

   Author: Mike Wall
   Date: 4/11/95
   Version: 1.

   Usage:
   		"sumlt <input lattice 1> <input lattice 2> <output
		lattice>"

		Input is two 3D lattices.  Output is a lattice which
		is the sum of the two.
   */








Sep 19 20:37 1995   Page 229


#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein1,
    *latticein2,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_wrote;

  LAT3D
    *lat1,
    *lat2;

  RFILE_DATA_TYPE *rfile;

  struct ijkcoords
    origin;

  /*
   * Set input line defaults:
   */

  latticein1 = stdin;
  latticein2 = stdin;
  latticeout = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 4:
    if ((latticeout = fopen(argv[3],"wb")) == NULL) {
      printf("\nCan't open %s.\n\n",argv[3]);
      exit(0);
    }
    case 3:
    if (strcmp(argv[2],"-") == 0) {
      latticein2 = stdin;
    }
    else {
      if ( (latticein2 = fopen(argv[2],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1],"-") == 0) {







Sep 19 20:37 1995   Page 230


      latticein1 = stdin;
    }
    else {
      if ( (latticein1 = fopen(argv[1],"rb")) == NULL ) {
	printf("\nCan't open %s.\n\n",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: sumlt <input lattice 1> <input lattice 2> "
	   "<output lattice>\n\n");
    exit(0);
  }

  /*
   * Initialize lattice:
   */

  if (((lat1 = linitlt()) == NULL) || ((lat2 = linitlt()) == NULL)) {
    perror("Couldn't initialize lattices.\n\n");
    exit(0);
  }

  /*
   * Read in lattices:
   */

  lat1->infile = latticein1;
  if (lreadlt(lat1) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  lat2->infile = latticein2;
  if (lreadlt(lat2) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the sum lattice:
 */

  lsumlt(lat1,lat2);

  /*
   * Write lattice to output file:
   */

  lat1->outfile = latticeout;
  if (lwritelt(lat1) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }








Sep 19 20:37 1995   Page 231


CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat1);
  lfreelt(lat2);

  /*
   * Close files:
   */

  fclose(latticeout);
  fclose(latticein1);
  fclose(latticein2);
}

::::::::::::::
sumrf.c
::::::::::::::
/* SUMRF.C - Sum two rfiles.

   Author: Mike Wall
   Date: 4/19/94
   Version: 1.

   "sumrf <input rfile 1> <input rfile 2> <output rfile>"

   Input is two rfiles.  Output is sum of rfiles, point-by-point.
   second.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*infile1,
	*infile2,
	*outfile;

  size_t
    i;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

/*
 * Set input line defaults:
 */
	
	infile1 = stdin;
	infile2 = stdin;







Sep 19 20:37 1995   Page 232


	outfile = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				outfile = stdout;
			}
			else {
			 if ( (outfile = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
		case 3:
			if (strcmp(argv[2], "-") == 0) {
				infile2 = stdin;
			}
			else {
			 if ( (infile2 = fopen(argv[2],"rb")) == NULL ) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 2:
			if ( (infile1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			}
			break;
		default:
			printf("\n Usage: sumrf <input rfile 1> "
				"<input rfile 2> <output rfile>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction images:
 */

  if ((imdiff1 = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

  if ((imdiff2 = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }

 /*
  * Read in rfiles:
  */








Sep 19 20:37 1995   Page 233


   imdiff1->infile = infile1;
   if (lreadrf(imdiff1) != 0) {
     perror(imdiff1->error_msg);
     goto CloseShop;
   }

   imdiff2->infile = infile2;
   if (lreadrf(imdiff2) != 0) {
     perror(imdiff2->error_msg);
     goto CloseShop;
   }

/*
 * Sum rfiles:
 */

   lsumrf(imdiff1,imdiff2);

/*
 * Write the output rfile:
 */

   imdiff1->outfile = outfile;
   if(lwriterf(imdiff1) != 0) {
     perror(imdiff1->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(infile1);
  fclose(infile2);
  fclose(outfile);

}

::::::::::::::
swapmw.c
::::::::::::::
#include<stdio.h>
#include<stdlib.h>

void main()
{
	char ch1,







Sep 19 20:37 1995   Page 234


		ch2;

	while( fread(&ch1, 1, 1, stdin) == 1) {
	  fread(&ch2, 1, 1, stdin);
	  fwrite(&ch2, 1, 1, stdout);
	  fwrite(&ch1, 1, 1, stdout);
	}
}
::::::::::::::
symlt.c
::::::::::::::
/* SYMLT.C - Symmetrize a lattice according to input line instructions.

   Author: Mike Wall
   Date: 2/28/95
   Version: 1.

   Usage:
   		"symlt <input lattice> <output lattice> <symmetry_operation>"

		Input are lattice and symmetry operation
		specification.  Output is symmetrized lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*latticein,
	*latticeout;

  char
    error_msg[LINESIZE];

  size_t
    symop;

  LAT3D
	*lat;

  RFILE_DATA_TYPE *rfile;

/*
 * Set input line defaults:
 */
	
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 4:
	  symop = atol(argv[3]);







Sep 19 20:37 1995   Page 235


	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    latticeout = stdout;
	  }
	  else {
	    if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: symlt <input lattice> "
		 "<output lattice> <symmetry_operation>\n\n"
		 "  Symmetry Operations:\n"
		 "    1 = P41\n\n");
	  exit(0);
	}

  /*
   * Initialize lattices:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

  /*
   * Perform symmetry operation:
   */

  lat->symop_index = symop;
  lsymlt(lat);

  /*







Sep 19 20:37 1995   Page 236


   * Write lattice to output file:
   */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(latticeout);
}


::::::::::::::
tag_overloads.c
::::::::::::::
/* TAG_OVERLOADS.C - Change 32767 to -1 (65535) in an input 16-bit greyscale
		image with a 4096 byte header (tv6 TIFF file).

   Author: Mike Wall
   Date: 2/26/94
   Version: 1.0
   Description:

		"tag_overloads <input file> <output file>"

		Input is a 16-bit 1024x1024 TV6 tiff image.
		Output is a 16-bit tiff image.
*/

#define LINESIZE 120
#define DEFAULT_HEADER_LENGTH 4096
#define DEFAULT_FILE_SIZE 2101248
#define MAX_PIXEL_VALUE 0xff7f		/* Remember...reversed byte order. */
#define OVERFLOW_TAG 0xffff		/* 65535 */

#include<stdio.h>

void main(int argc, char *argv)
{

	short ltag_overloads(unsigned short *image, size_t imagelength,
				short max_pixel_value, short overflow_tag);







Sep 19 20:37 1995   Page 237



	FILE
		*f_in,			/* Input file */
		*f_out;			/* Output file */

	char
		*filename;		/* Generic filename string */

	char
		*header;		/* TIFF header buffer */

	size_t
		filesize,		/* Size of the file in bytes */
		imagesize,		/* Sz of the img (no hdr) in bytes */
		imagelength,		/* Sz of img in pixels */
		num_read,		/* Number of structs read */
		num_wrote,		/* Number of structs written */
		i,			/* Counting index */
		header_length = DEFAULT_HEADER_LENGTH; /* header length in chars */

	unsigned short
		*image;		/* Buffer for image */

	filename = (char *)malloc(sizeof(char)*(LINESIZE+1));
        if (!filename) {
                printf("\nCan't allocate image arrays.  Exiting.\n\n");
                exit(0);
        }
	if (argc < 3) {
		printf("\n     Usage: tag_overloads <input file> "
			"<output file>\n\n");
		exit(0);
	}

/*
 * Open input and output files:
 */

	strcpy(filename,argv[1]);
	if ( (f_in = fopen(filename,"rb")) == NULL ) {
		printf("Can't open %s.",filename);
		exit(0);
	}
	strcpy(filename,argv[2]);
	if ( (f_out = fopen(filename,"wb")) == NULL ) {
		printf("Can't open %s.",filename);
		exit(0);
	}


/*
 * Allocate memory for the header:
 */

	header = (char *)malloc(sizeof(char)*(header_length+1));
	if (!header) {







Sep 19 20:37 1995   Page 238


		printf("Can't allocate image arrays.  Exiting.\n");
		exit(0);
	}

/*
 * Read the input image:
 */

	filesize = DEFAULT_FILE_SIZE;
	imagesize = filesize-header_length;
	imagelength = imagesize/2;
        image = (unsigned short *)malloc(sizeof(unsigned short)*
			(imagelength+1));
	if (!image) {
		printf("\nCan't allocate image array.  Exiting.\n\n");
		exit(0);
	}

/*
 * Read header:
 */

	num_read = fread(header,sizeof(char),header_length,f_in);

/*
 * Read image:
 */

	num_read = fread(image,sizeof(unsigned short),imagelength,f_in);
	if (ferror(f_in)) {
		printf("Error reading file %s.",filename);
	}


/*
 * Replace maximum pixel value with standard overflow tag:
 */

	ltag_overloads(image, imagelength, MAX_PIXEL_VALUE, OVERFLOW_TAG);

	i = 0;
	while (i < imagelength) {
		if (image[i] == MAX_PIXEL_VALUE) {
			image[i] = OVERFLOW_TAG;
		}
		i++;
	}


/*
 * Write TIFF header:
 */

	num_wrote = fwrite(header, sizeof(char), header_length, f_out);

/*







Sep 19 20:37 1995   Page 239


 * Write the output image:
 */

	num_wrote = fwrite(image, sizeof(short), imagelength, f_out);

/*
 * Free allocated memory:
 */

	free((char *)filename);
	free((short *)image);
	free((char *)header);
}

short ltag_overloads(unsigned short *image, size_t imagelength,
			short max_pixel_value, short overflow_tag)
{
	long
		i;

	i = 0;
	while (i < imagelength) {
		if (image[i] == max_pixel_value) {
			image[i] = overflow_tag;
		}
		i++;
	}
	return(0);
}
::::::::::::::
tagim.c
::::::::::::::
/* TAGIM.C - Create an image with constant pixel value based on an input
		image format.

   Author: Mike Wall
   Date: 4/18/94
   Version: 1.

   "tagim <image in> <constant> <image out>"

   Input is image and constant.  Output is input image with all pixel values
   of value <constant> converted to an ingore_tag.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  size_t
    i;







Sep 19 20:37 1995   Page 240



  DIFFIMAGE
	*imdiff;

  IMAGE_DATA_TYPE
	image_value;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
                case 3:
			image_value = atof(argv[2]);
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: tagim <image in> <constant> "
			       "<image out>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }








Sep 19 20:37 1995   Page 241



 /*
  * Read diffraction image:
  */

   imdiff->infile = imagein;
   if (lreadim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

/*
 * Set image to constant:
 */

   imdiff->mask_tag = (IMAGE_DATA_TYPE)image_value;
   ltagim(imdiff);

/*
 * Write the output image:
 */

   imdiff->outfile = imageout;
   if(lwriteim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
taglt.c
::::::::::::::
/* TAGLT.C - Convert all voxels of specified value in a lattice to an
             ignore_tag.

   Author: Mike Wall
   Date: 5/5/95
   Version: 1.

   Usage:







Sep 19 20:37 1995   Page 242


   		"taglt <input lattice> <output lattice> <target value>"

		Input is a scalar and an input
			lattice.  Output is a lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *latticein,
    *latticeout;

  char
    error_msg[LINESIZE];

  size_t
    i,
    j,
    k,
    num_read,
    num_wrote;

  LAT3D
    *lat;

  RFILE_DATA_TYPE
    *rfile;

  float
    target_value;

/*
 * Set input line defaults:
 */
	target_value = 1.;
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 4:
	  target_value = atof(argv[3]);
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    latticeout = stdout;
	  }
	  else {
	    if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }







Sep 19 20:37 1995   Page 243


	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: taglt <input lattice> <output lattice> "
		 "<scale factor>\n\n");
	  exit(0);
	}

  /*
   * Initialize lattice:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");
    exit(0);
  }

/*
 * Generate the scaled lattice:
 */

  lat->rfile[0] = target_value;
  ltaglt(lat);

/*
 * Write lattice to output file:
 */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*







Sep 19 20:37 1995   Page 244


   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(latticeout);
}
::::::::::::::
tagneg.c
::::::::::::::
/* TAGIM.C - Create an image with constant pixel value based on an input
		image format.

   Author: Mike Wall
   Date: 4/18/94
   Version: 1.

   "tagim <image in> <constant> <image out>"

   Input is image and constant.  Output is input image with all pixel values
   of value <constant> converted to an ingore_tag.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff;

  IMAGE_DATA_TYPE
	image_value;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */







Sep 19 20:37 1995   Page 245


	switch(argc) {
		case 4:
			if (strcmp(argv[3], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[3],"wb")) == NULL ) {
				printf("Can't open %s.",argv[3]);
				exit(0);
			 }
			}
                case 3:
			image_value = atof(argv[2]);
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: tagim <image in> <constant> "
			       "<image out>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }


 /*
  * Read diffraction image:
  */

   imdiff->infile = imagein;
   if (lreadim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

/*
 * Set image to constant:
 */

   imdiff->mask_tag = (IMAGE_DATA_TYPE)image_value;
   ltagim(imdiff);







Sep 19 20:37 1995   Page 246



/*
 * Write the output image:
 */

   imdiff->outfile = imageout;
   if(lwriteim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
tailc.c
::::::::::::::
/*
 * TAILC.C	- Output the tail of a specified file.  Use number of
		characters given on input line.

   Version: 1.0
   Date: 3/17/94

	Input line is:
			"tailc -<number of characters> <input file>"

*/

#include<stdio.h>
#include<stdlib.h>

void main(int argc, char *argv[])
{
	FILE
		*infile;
	
	char
		*tail,
		*head;

	size_t







Sep 19 20:37 1995   Page 247


		header_length,
		filesize,
		tail_length,
		num_read,
		num_wrote;

	switch(argc) {
		case 4:
			if (strcmp(argv[3],"-") == 0) {
				infile = stdin;
			}
			else {
			 if ((infile = fopen(argv[3],"rb")) == NULL) {
				printf("Can't open %s.",argv[2]);
				exit(0);
			 }
			}
		case 3:
			if (!(filesize = atol(argv[2]))) {
			  printf("Invalid file size.\n");
			  exit(0);
			}
		case 2:
			if (argv[1][0] == '-') {
			  if (!(tail_length = atol(argv[1]+1))) {
			    printf("Incorrect syntax for tail length.\n");
			    exit(0);
			  }
			}
			else {
				printf("Must have '-' in front "
					"of tail length.\n");
				exit(0);
			}
			break;
		default:
			printf("\n   Usage: tailc -<number of chars> "
				"<input file>\n\n");
	}
	header_length = filesize - tail_length;
	tail = (char *)malloc(tail_length+1);
	head = (char *)malloc(header_length+1);
	num_read = fread(head, sizeof(char), header_length, infile);
	num_read = fread(tail, sizeof(char), tail_length, infile);
	num_wrote = fwrite(tail, sizeof(char), tail_length, stdout);

	free((char *)tail);
	free((char *)head);
}
::::::::::::::
thrshim.c
::::::::::::::
/* THRSHIM.C - Set all pixels above and below given thresholds equal to an
		ignore_tag.

   Author: Mike Wall







Sep 19 20:37 1995   Page 248


   Date: 5/13/94
   Version: 1.

   "thrshim <image in> <lower> <upper> <image out>"

   Input is image and upper and lower thresholds.  Output is input image
   with all pixel values outside of thresholds converted to an ingore_tag.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  size_t
    i;

  DIFFIMAGE
	*imdiff;

  IMAGE_DATA_TYPE
	upper_threshold,
	lower_threshold;

/*
 * Set input line defaults:
 */
	
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 5:
			if (strcmp(argv[4], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[4],"wb")) == NULL ) {
				printf("Can't open %s.",argv[4]);
				exit(0);
			 }
			}
                case 4:
			upper_threshold = (IMAGE_DATA_TYPE)atoi(argv[3]);
                case 3:
			lower_threshold = (IMAGE_DATA_TYPE)atoi(argv[2]);
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;







Sep 19 20:37 1995   Page 249


			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: thrshim <image in> <lower> <upper> "
			       "<image out>\n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }


 /*
  * Read diffraction image:
  */

   imdiff->infile = imagein;
   if (lreadim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

/*
 * Set image to constant:
 */

   imdiff->lower_threshold = lower_threshold;
   imdiff->upper_threshold = upper_threshold;
   lthrshim(imdiff);

/*
 * Write the output image:
 */

   imdiff->outfile = imageout;
   if(lwriteim(imdiff) != 0) {
     perror(imdiff->error_msg);
     goto CloseShop;
   }

 CloseShop:

/*
 * Free allocated memory:







Sep 19 20:37 1995   Page 250


 */

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
tmp.c
::::::::::::::
/* INTDFIM.C - Integrate diffuse features in a diffraction image and output to
               a file.

   Author: Mike Wall
   Date: 5/28/94
   Version: 1.0

   "intdfim <diffuse features in> <image in> <diffuse features out>"

   Input is ascii diffuse features file and input image.  Output is
   diffuse features file.

*/

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *featurein,
    *featureout,
    *imagein;

  char
    error_msg[LINESIZE];

  long
    i,
    ii;

  DIFFIMAGE
    *imdiff;

  /*
   * Set input line defaults:
   */

  featurein = stdin;
  imagein = stdin;
  featureout = stdout;







Sep 19 20:37 1995   Page 251



  /*
   * Read information from input line:
   */

  switch(argc) {
  case 4:
    if (strcmp(argv[3], "-") == 0) {
      featureout = stdout;
    }
    else {
      if ( (featureout = fopen(argv[3],"wb")) == NULL ) {
	printf("Can't open %s.",argv[3]);
	exit(0);
      }
    }
  case 3:
    if (strcmp(argv[2], "-") == 0) {
      imagein = stdin;
    }
    else {
      if ( (imagein = fopen(argv[2],"rb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }
    }
  case 2:
    if ( (featurein = fopen(argv[1],"r")) == NULL ) {
      printf("Can't open %s.",argv[1]);
      exit(0);
    }
    break;
  default:
    printf("\n Usage: intdfim <diffuse features in> "
	   "<image in> <diffuse features out> \n\n");
    exit(0);
  }

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }







Sep 19 20:37 1995   Page 252



  /*
   * Read diffuse features file:
   */

  imdiff->infile = featurein;
  if (lreaddf(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Integrate diffuse features:
   */

  if (lintdfim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Write the output diffuse features file:
   */

  imdiff->outfile = featureout;
  if(lwritedf(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

 CloseShop:

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(featurein);
  fclose(featureout);
}

::::::::::::::
totiff8.c
::::::::::::::
/* TOTIFF8.C - Convert a 16-bit 1024x1024 TV6 tiff image to an 8-bit tiff image.
   Author: Mike Wall
   Date: 8/17/93
   Version: 1.0
   Description:

		"totiff8 <input file> <output file>"

		Input is a 16-bit 1024x1024 TV6 tiff image.
		Output is an 8-bit tiff image.







Sep 19 20:37 1995   Page 253


*/

#define LINESIZE 80
#define DEFAULT_HEADER_LENGTH 4096
#define DEFAULT_FILE_SIZE 2101248

#include<stdio.h>

union data_union {
	short two_byte;
	struct {
		char low_byte;
		char high_byte;
	} one_byte;
};

void main(int argc, char *argv[])
{
	FILE
		*f_in,
		*f_out;

	char
		*filename;

	char
		*outstream,
		*header;

	size_t
		filesize,
		imagesize,
		imagelength,
		num_read,
		num_wrote,
		i,
		header_length = DEFAULT_HEADER_LENGTH;

	unsigned short
		handle,
		max,
		min,
		scaled_num;

	short
		*instream;

	union data_union
		pix;

	filename = (char *)malloc(sizeof(char)*(LINESIZE+1));
        if (!filename) {
                printf("Can't allocate image arrays.  Exiting.\n");
                exit(0);
        }
	if (argc < 3) {







Sep 19 20:37 1995   Page 254


		printf("\n     Usage: totiff8 <input file> <output file>\n");
		exit(0);
	}

/*
 * Open input and output files:
 */

	strcpy(filename,argv[1]);
	if ( (f_in = fopen(filename,"rb")) == NULL ) {
		printf("Can't open %s.",filename);
		exit(0);
	}
	strcpy(filename,argv[2]);
	if ( (f_out = fopen(filename,"wb")) == NULL ) {
		printf("Can't open %s.",filename);
		exit(0);
	}


/*
 * Allocate memory for the header:
 */

	header = (char *)malloc(sizeof(char)*(header_length+1));

/*
 * Read the input image:
 */

/*	handle = fileno(f_in);
	if ((filesize = filelength(handle)) == 0) {
		printf("Can't get length of file.\n");
		exit(0);
	}
*/
	filesize = DEFAULT_FILE_SIZE;
	imagesize = filesize-header_length;
	imagelength = imagesize/2;
	outstream = (char *)malloc(sizeof(char)*(imagelength+1));
        instream = (short *)malloc(sizeof(short)*(imagelength+1));
	if (!(outstream && instream)) {
		printf("Can't allocate image arrays.  Exiting.\n");
		exit(0);
	}
	num_read = fread(header,sizeof(char),header_length,f_in);
/*
 * Modify header to indicate 8-bit tiff:
 */

        header[0x88] = 0x08;		/* Bits per pixel */
	header[0xDE] = 0x10;		/* Strip size change */
	header[0x178] = 0x08;		/* TV6 Significant bpp */

	num_read = fread(instream,sizeof(short),imagelength,f_in);
	if (ferror(f_in)) {







Sep 19 20:37 1995   Page 255


		printf("Error reading file %s.",filename);
	}


/*
 * Generate output image:
 */

	i = 0;
	while (i < imagelength) {
		pix.two_byte = instream[i];
		outstream[i] = pix.one_byte.high_byte;
		i++;
	}


/*
 * Write TIFF header:
 */

	num_wrote = fwrite(header, sizeof(char), header_length, f_out);

/*
 * Write the output image:
 */

	num_wrote = fwrite(outstream, sizeof(char), imagelength, f_out);

/*
 * Free allocated memory:
 */

	free((char *)filename);
	free((short *)instream);
	free((char *)outstream);
	free((char *)header);
}
::::::::::::::
tst.c
::::::::::::::
void main()
{
	int i;

	for(i=0;i<100;i++) {
		printf("Line number %d.\n",i);
	}
}

::::::::::::::
tst3d.c
::::::::::::::
#include<stdio.h>
#include<math.h>
#include<stdlib.h>








Sep 19 20:37 1995   Page 256


#define DIM 101
#define LOWI -10.5
#define HIGHI 10.5
#define LOWJ -10.5
#define HIGHJ 10.5
#define LOWK -10.5
#define HIGHK 10.5
void main(void)
{
	int
		i,
		j,
		k;

	long
		res[3] = {DIM, DIM, DIM};

	float
		ifl,
		jfl,
		kfl,
		bBox[6] = {LOWI*2, HIGHI*2,
				LOWJ, HIGHJ,
				LOWK, HIGHK},
		val,
		isc,
		jsc,
		ksc;

	isc = (HIGHI - LOWI) / (float)DIM;
	jsc = (HIGHJ - LOWJ) / (float)DIM;
	ksc = (HIGHK - LOWK) / (float)DIM;
	fwrite(res, sizeof(long), 3, stdout);
	fwrite(bBox, sizeof(float), 6, stdout);
	for (k=1;k<=DIM;k++) {
		for(j=1;j<=DIM;j++) {
			for (i=1;i<=DIM;i++) {
				ifl = LOWI + isc*(float)i;
				jfl = LOWJ + jsc*(float)j;
				kfl = LOWK + ksc*(float)k;
				val = fsqrt(ifl*ifl+jfl*jfl+kfl*kfl);
				fwrite(&val, sizeof(float), 1, stdout);
			}
		}
	}
}
::::::::::::::
waveim.c
::::::::::::::
/* WAVEIM - Create an image with a fixed length scale fulctuation.

   Author: Mike Wall
   Date: 4/6/95
   Version: 1.

   "waveim <image in> <constant> <image out>"







Sep 19 20:37 1995   Page 257



   Input is image, amplitude and pitch.
   Output is wavy image of type input image.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
    *imagein,
    *imageout;

  size_t
    i;

  DIFFIMAGE
    *imdiff;

  IMAGE_DATA_TYPE
    image_value;

  float
    amplitude,
    pitch;

  /*
   * Set input line defaults:
   */

  imagein = stdin;
  imageout = stdout;

  /*
   * Read information from input line:
   */
  switch(argc) {
    case 5:
    pitch = atof(argv[4]);
    case 4:
    amplitude = atof(argv[3]);
    case 3:
    if (strcmp(argv[2], "-") == 0) {
      imageout = stdout;
    }
    else {
      if ( (imageout = fopen(argv[2],"wb")) == NULL ) {
	printf("Can't open %s.",argv[2]);
	exit(0);
      }
    }
    case 2:
    if (strcmp(argv[1], "-") == 0) {
      imagein = stdin;
    }







Sep 19 20:37 1995   Page 258


    else {
      if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
	printf("Can't open %s.",argv[1]);
	exit(0);
      }
    }
    break;
    default:
    printf("\n Usage: waveim <image in> <image out> <amplitude> "
	   "<pitch>\n\n");
    exit(0);
  }

  /*
   * Initialize diffraction image:
   */

  if ((imdiff = linitim()) == NULL) {
    perror("\nCouldn't initialize diffraction image.\n\n");
    exit(0);
  }


  /*
   * Read diffraction image:
   */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

  /*
   * Set input line specs:
   */

  imdiff->amplitude = amplitude;
  imdiff->pitch = pitch;

  /*
   * Create wavy image:
   */

  lwaveim(imdiff);

  /*
   * Write the output image:
   */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }








Sep 19 20:37 1995   Page 259


  CloseShop:

  /*
   * Free allocated memory:
   */

  lfreeim(imdiff);

  /*
   * Close files:
   */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
windim.c
::::::::::::::
/* WINDIM.C - Mark all pixels outside a window in an image with an ignore tag.

   Author: Mike Wall
   Date: 4/25/94
   Version: 1.

   "windim <image in> <x_lower_bound> <x_upper_bound> <y_lower_bound>
		<y_upper_bound> <image out>

   Input is diffraction image.  Output is 16-bit
     image of specified size (1024 x 1024 default), with pixels outside bounds
     marked to be ignored.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein,
	*imageout;

  char
    error_msg[LINESIZE];

  long
	i,
	ii;

  DIFFIMAGE
	*imdiff;

  struct rccoords
	upper_bound,
	lower_bound;







Sep 19 20:37 1995   Page 260



/*
 * Set input line defaults:
 */
	upper_bound.r = DEFAULT_WINDOW_UPPER;
	upper_bound.c = DEFAULT_WINDOW_UPPER;
	lower_bound.c = DEFAULT_WINDOW_LOWER;
	lower_bound.c = DEFAULT_WINDOW_LOWER;
	imagein = stdin;
	imageout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 7:
			if (strcmp(argv[6], "-") == 0) {
				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[6],"wb")) == NULL ) {
				printf("Can't open %s.",argv[6]);
				exit(0);
			 }
			}
		case 6:
			upper_bound.r = (RCCOORDS_DATA)atol(argv[5]);
		case 5:
			lower_bound.r = (RCCOORDS_DATA)atol(argv[4]);
		case 4:
			upper_bound.c = (RCCOORDS_DATA)atol(argv[3]);
		case 3:
			lower_bound.c = (RCCOORDS_DATA)atol(argv[2]);
		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein = stdin;
			}
			else {
			 if ( (imagein = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: windim <image in> <x_lower_bound> "
			       "<x_upper_bound> <y_lower_bound> "
			       "<y_upper_bound> <image out> \n\n");
			exit(0);
	}

/*
 * Initialize diffraction image:
 */

  if ((imdiff = linitim()) == NULL) {







Sep 19 20:37 1995   Page 261


    perror("Couldn't initialize diffraction image.\n\n");
    exit(0);
  }

/*
 * Read diffraction image:
 */

  imdiff->infile = imagein;
  if (lreadim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

/*
 * Set window parameters:
 */

  imdiff->window_upper = upper_bound;
  imdiff->window_lower = lower_bound;

/*
 * Mark pixels outside window as ignored:
 */

  lwindim(imdiff);

/*
 * Write the output image:
 */

  imdiff->outfile = imageout;
  if(lwriteim(imdiff) != 0) {
    perror(imdiff->error_msg);
    goto CloseShop;
  }

CloseShop:

  lfreeim(imdiff);

/*
 * Close files:
 */

  fclose(imagein);
  fclose(imageout);

}

::::::::::::::
writehdr.c
::::::::::::::
#include<stdio.h>
#include<stdlib.h>








Sep 19 20:37 1995   Page 262


void main()
{
	long
		lattice_size = 16;

	float
		lower_bound = 0,
		upper_bound = 1;

	fwrite(&lattice_size,sizeof(long),1,stdout);
	fwrite(&lattice_size,sizeof(long),1,stdout);
	fwrite(&lattice_size,sizeof(long),1,stdout);
	fwrite(&lower_bound,sizeof(float),1,stdout);
	fwrite(&upper_bound,sizeof(float),1,stdout);
	fwrite(&lower_bound,sizeof(float),1,stdout);
	fwrite(&upper_bound,sizeof(float),1,stdout);
	fwrite(&lower_bound,sizeof(float),1,stdout);
	fwrite(&upper_bound,sizeof(float),1,stdout);
}
::::::::::::::
xflt.c
::::::::::::::
/* XFLT.C - Transform a lattice according to input line instructions.

   Author: Mike Wall
   Date: 3/24/95
   Version: 1.

   Usage:
   		"xflt <input lattice> <output lattice> <operation>"

		Input are lattice and operation
		specification.  Output is transformed lattice.
   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*latticein,
	*latticeout;

  char
    error_msg[LINESIZE];

  int
    xfop;

  LAT3D
	*lat;

  RFILE_DATA_TYPE *rfile;

/*
 * Set input line defaults:







Sep 19 20:37 1995   Page 263


 */
	
	latticein = stdin;
	latticeout = stdout;

/*
 * Read information from input line:
 */
	switch(argc) {
	  case 4:
	  xfop = atoi(argv[3]);
	  case 3:
	  if (strcmp(argv[2],"-") == 0) {
	    latticeout = stdout;
	  }
	  else {
	    if ((latticeout = fopen(argv[2],"wb")) == NULL) {
	      printf("\nCan't open %s.\n\n",argv[2]);
	      exit(0);
	    }
	  }
	  case 2:
	  if (strcmp(argv[1],"-") == 0) {
	    latticein = stdin;
	  }
	  else {
	    if ( (latticein = fopen(argv[1],"rb")) == NULL ) {
	      printf("\nCan't open %s.\n\n",argv[1]);
	      exit(0);
	    }
	  }
	  break;
	  default:
	  printf("\n Usage: xflt <input lattice> "
		 "<output lattice> <operation>\n\n"
		 "  Operations:\n"
		 "    1 = Mirror reflection through x-z plane\n\n");
	  exit(0);
	}

  /*
   * Initialize lattices:
   */

  if ((lat = linitlt()) == NULL) {
    perror("Couldn't initialize lattice.\n\n");
    exit(0);
  }

  /*
   * Read in lattice:
   */

  lat->infile = latticein;
  if (lreadlt(lat) != 0) {
    perror("Couldn't read lattice.\n\n");







Sep 19 20:37 1995   Page 264


    exit(0);
  }

  /*
   * Perform symmetry operation:
   */

  switch(xfop) {
    case 1:
    if (lxf1lt(lat) != 0) {
      perror(lat->error_msg);
      goto CloseShop;
    }
    break;
    default:
    printf("\n Usage: xflt <input lattice> "
	   "<output lattice> <operation>\n\n"
	   "  Operations:\n"
	   "    1 = Mirror reflection through x-z plane\n\n");
    exit(0);
    goto CloseShop;
  }

  /*
   * Write lattice to output file:
   */

  lat->outfile = latticeout;
  if (lwritelt(lat) != 0) {
    perror("Couldn't write lattice.\n\n");
    exit(0);
  }

CloseShop:

  /*
   * Free allocated memory:
   */

  lfreelt(lat);

  /*
   * Close files:
   */

  fclose(latticein);
  fclose(latticeout);
}


::::::::::::::
xfmask.c
::::::::::::::
/* XFMASK.C - Tag pixels as ignored in one image which in a second image are
		tagged as either overloads or ignored.  Positions are
		reffered to origin.







Sep 19 20:37 1995   Page 265



   Author: Mike Wall
   Date: 4/11/94
   Version: 1.

   "xfmask <input image 1> <input image 2> <output image>"

   Input two diffraction images in TIFF TV6 format.  Output is two rfiles
   with scale and offset as function of radius.

   */

#include<mwmask.h>

void main(int argc, char *argv[])
{
  FILE
	*imagein1,
	*imagein2,
	*imageout;

  size_t
    i,
    num_wrote,
    num_read;

  DIFFIMAGE
	*imdiff1,
	*imdiff2;

  int
	got_r2 = 0,
	got_c2 = 0;

  struct rccoords
	origin1,
	origin2;

/*
 * Set input line defaults:
 */
	
	imagein1 = stdin;
	imagein2 = stdin;
	imageout = stdout;
        origin1.r = DEFAULT_IMAGE_ORIGIN;
	origin1.c = DEFAULT_IMAGE_ORIGIN;
	origin2.r = DEFAULT_IMAGE_ORIGIN;
	origin2.c = DEFAULT_IMAGE_ORIGIN;

/*
 * Read information from input line:
 */
	switch(argc) {
		case 8:
			if (strcmp(argv[7], "-") == 0) {







Sep 19 20:37 1995   Page 266


				imageout = stdout;
			}
			else {
			 if ( (imageout = fopen(argv[7],"wb")) == NULL ) {
				printf("Can't open %s.",argv[7]);
				exit(0);
			 }
			}
                case 7:
			origin2.r = (RCCOORDS_DATA)atoi(argv[6]);
			got_r2 = 1;
		case 6:
			origin2.c = (RCCOORDS_DATA)atoi(argv[5]);
			got_c2 = 1;
		case 5:
			if (strcmp(argv[4], "-") == 0) {
				imagein2 = stdin;
			}
			else {
			 if ( (imagein2 = fopen(argv[4],"rb")) == NULL ) {
				printf("Can't open %s.",argv[4]);
				exit(0);
			 }
			}
                case 4:
			origin1.r = (RCCOORDS_DATA)atoi(argv[3]);
			if (got_r2 == 0) origin2.r = origin1.r;
		case 3:
			origin1.c = (RCCOORDS_DATA)atoi(argv[2]);
			if (got_c2 == 0) origin2.c = origin1.c;

		case 2:
			if (strcmp(argv[1], "-") == 0) {
				imagein1 = stdin;
			}
			else {
			 if ( (imagein1 = fopen(argv[1],"rb")) == NULL ) {
				printf("Can't open %s.",argv[1]);
				exit(0);
			 }
			}
			break;
		default:
			printf("\n Usage: xfmask <input image 1> <x origin 1> "
				"<y origin 1> <input image 2> <x origin 2> "
				"<y origin 2> <output image>\n\n");
			exit(0);
	}
/*
 * Initialize diffraction images:
 */

  if (((imdiff1 = linitim()) == NULL) || ((imdiff2 = linitim()) == NULL)) {
    perror("Couldn't initialize diffraction images.\n\n");
    exit(0);
  }







Sep 19 20:37 1995   Page 267



/*
 * Set main defaults:
 */

  imdiff1->origin = origin1;
  imdiff2->origin = origin2;


/*
 * Read diffraction images:
 */

  imdiff1->infile = imagein1;
  if (lreadim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

  imdiff2->infile = imagein2;
  if (lreadim(imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

  if (lxfmask(imdiff1,imdiff2) != 0) {
    perror(imdiff2->error_msg);
    goto CloseShop;
  }

/*
 * Write the output image:
 */

  imdiff1->outfile = imageout;
  if(lwriteim(imdiff1) != 0) {
    perror(imdiff1->error_msg);
    goto CloseShop;
  }

 CloseShop:

/*
 * Free allocated memory:
 */

  lfreeim(imdiff1);
  lfreeim(imdiff2);

/*
 * Close files:
 */

  fclose(imagein1);
  fclose(imagein2);
  fclose(imageout);







Sep 19 20:37 1995   Page 268


}

::::::::::::::
xpl2mw.c
::::::::::::::
#include<stdio.h>
#include<math.h>
#include<stdlib.h>

#define DIM 20
#define LOWI -10.5
#define HIGHI 10.5
#define LOWJ -10.5
#define HIGHJ 10.5
#define LOWK -10.5
#define HIGHK 10.5
void main(void)
{
	int
		i,
		nrem,
		k;
	long
		count,
		matrix_size;

	long
		res[3];

	float
		max = 0,
		bBox[6],
		val[6];
	
	char
		inline[80];

	gets(inline);
	gets(inline);
	sscanf(inline,"%d",&nrem);
	for(k=1;k<=nrem;k++) {
		gets(inline);
	}
	gets(inline);
	sscanf(inline,"%12ld%12g%12g%12ld%12g%12g%12ld%12g%12g",
					&res[0],&bBox[0],&bBox[1],
					&res[1],&bBox[2],&bBox[3],
					&res[2],&bBox[4],&bBox[5]);
	res[0] = (long)(bBox[1] - bBox[0])+1;
	res[1] = (long)(bBox[3] - bBox[2])+1;
	res[2] = (long)(bBox[5] - bBox[4])+1;
	fwrite(res, sizeof(long), 3, stdout);
	fwrite(bBox, sizeof(float), 6, stdout);
	matrix_size = (res[0] * res[1]);
	gets(inline);
	for (k=1;k<=res[2];k++) {







Sep 19 20:37 1995   Page 269


		gets(inline);		/* skip k-index line */
		count = 0;
		while(count < matrix_size) {
		  gets(inline);
		  sscanf(inline,"%12g%12g%12g%12g%12g%12g",
						&val[0],&val[1],&val[2],
						&val[3],&val[4],&val[5]);
		  count += 6;
		  if (count > matrix_size) {
		    fwrite(val, sizeof(float), count % matrix_size, stdout);
		  }
		  else {
		    fwrite(val, sizeof(float), 6, stdout);
		  }
		}
	}
	printf("\n\n%ld %ld %ld\n\n",res[0],res[1],res[2]);
}











































